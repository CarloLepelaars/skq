{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"skq","text":"<p>Scientific Toolkit for Quantum Computing</p> <p>This library is used in the q4p (Quantum Computing for Programmers) course.</p> <p></p> <p>NOTE: This library is developed for educational purposes. While we strive for correctness of everything, the code is provided as is and not guaranteed to be bug-free. For sensitive applications make sure you check computations. </p>"},{"location":"#why-skq","title":"Why SKQ?","text":"<ul> <li>Exploration: Play with fundamental quantum building blocks using NumPy.</li> <li>Education: Learn quantum computing concepts and algorithms.</li> <li>Integration: Combine classical components with quantum components.</li> <li>Democratize quantum for Python programmers and data scientists: Develop quantum algorithms in your favorite environment and easily export to your favorite quantum computing platform for running on real quantum hardware.</li> </ul>"},{"location":"#install","title":"Install","text":"<pre><code>pip install -U skq\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#circuit-conversion","title":"Circuit Conversion","text":"<p>Run this code snippet to initialize Grover's algorithm and convert to Qiskit to run on quantum hardware. The algorithm can also be run within <code>skq</code> as a classical simulation.</p> <pre><code>from skq.circuits import Grover\n\n# Initialize Grover's search skq Circuit\ncircuit = Grover().circuit(n_qubits=3, target_state=np.array([0, 0, 0, 0, 1, 0, 0, 0]), n_iterations=1)\n\n# Conversion to Qiskit\nqiskit_circuit = circuit.convert(framework=\"qiskit\")\nqiskit_circuit.draw()\n#      \u250c\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u250c\u2500\u2510      \n# q_0: \u2524 H \u251c\u25240             \u251c\u25240                 \u251c\u2524M\u251c\u2500\u2500\u2500\u2500\u2500\u2500\n#      \u251c\u2500\u2500\u2500\u2524\u2502              \u2502\u2502                  \u2502\u2514\u2565\u2518\u250c\u2500\u2510   \n# q_1: \u2524 H \u251c\u25241 PhaseOracle \u251c\u25241 GroverDiffusion \u251c\u2500\u256b\u2500\u2524M\u251c\u2500\u2500\u2500\n#      \u251c\u2500\u2500\u2500\u2524\u2502              \u2502\u2502                  \u2502 \u2551 \u2514\u2565\u2518\u250c\u2500\u2510\n# q_2: \u2524 H \u251c\u25242             \u251c\u25242                 \u251c\u2500\u256b\u2500\u2500\u256b\u2500\u2524M\u251c\n#      \u2514\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551  \u2551 \u2514\u2565\u2518\n# c: 3/\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2569\u2550\u2550\u2569\u2550\n#                                                0  1  2 \n\n# Run circuit as classical simulation\nprint(grover([1,0,0,0,0,0,0,0]))\n# array([0.03125, 0.03125, 0.03125, 0.03125, 0.78125, 0.03125, 0.03125, 0.03125])\n</code></pre>"},{"location":"#circuits-from-scratch","title":"Circuits from scratch","text":"<p>You can also build your own custom circuits from scratch using individual gates. All gates can be converted to popular frameworks like Qiskit and OpenQASM.</p> <pre><code>from skq.gates import H, I, CX\nfrom skq.circuits import Concat, Circuit\n\nH() # Hadamard gate (NumPy array)\n# H([[ 0.70710678+0.j,  0.70710678+0.j],\n#    [ 0.70710678+0.j, -0.70710678+0.j]])\n\nI() # Identity gate (NumPy array)\n# I([[1.+0.j, 0.+0.j],\n#    [0.+0.j, 1.+0.j]])\n\nCX() # CNOT gate (NumPy array)\n# CX([[1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n#     [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n#     [0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j],\n#     [0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j]])\n\n# Initialize Bell State skq Circuit\ncircuit = Circuit([Concat([H(), I()]), CX()])\n\n# Simulate circuit classically\nstate = np.array([1, 0, 0, 0]) # |00&gt; state\ncircuit(state)\n# array([0.70710678+0.j, 0, 0, 0.70710678+0.j])\n\n# Conversion to Qiskit (Identity gates are removed)\nqiskit_circuit = circuit.convert(framework=\"qiskit\")\nqiskit_circuit.draw()\n#      \u250c\u2500\u2500\u2500\u2510     \n# q_0: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\n#      \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n# q_1: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n#           \u2514\u2500\u2500\u2500\u2518\n\n# Conversion to OpenQASM\nqasm_circuit = circuit.convert(framework=\"qasm\")\nprint(qasm_circuit)\n# h q[0];\n# cx q[0], q[1];\n</code></pre> <p></p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for considering to contribute to <code>skq</code>! Here we provide some general guidelines to streamline the contribution process. The goal of this library is to empower Python programmers to easily build their own quantum circuits and simulate them. <code>skq</code> also gives people to option to convert to popular quantum computing frameworks so the circuits can be put on real quantum computers. Lastly, <code>skq</code> is used in the q4p (Quantum Computing for Programmers) course for quantum education.</p>"},{"location":"contributing/#before-you-start","title":"Before you start","text":"<ul> <li> <p>Fork skq from Github.</p> </li> <li> <p>install <code>skq</code> in editable mode:</p> </li> </ul> <pre><code>pip install uv\nuv pip install -e .\n</code></pre>"},{"location":"contributing/#how-you-can-contribute","title":"How you can contribute","text":"<p>We always welcome contributions to <code>skq</code>. There are several aspects to this repository:</p> <ol> <li>Gates: This section provides all the gates from which quantum circuits are built. We welcome corrections, new features and gates. If you would like to contribute a new gate, please create a Github issue first so we can discuss the idea. Please create a Pull Request (PR) with your changes so we can review them. Look at the existing gates for inheritance structures and implementation details.</li> </ol> <p>For example, for Qubit gates we inherit from <code>QubitGate</code> and implement at least <code>__new__</code> <code>to_qiskit</code>, <code>to_pennylane</code> and <code>to_qasm</code> methods.</p> <pre><code>class I(QubitGate):\n    \"\"\"\n    Identity gate:\n    [[1, 0]\n    [0, 1]]\n    \"\"\"\n    def __new__(cls):\n        return super().__new__(cls, np.eye(2))\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.IGate:\n        return qiskit.circuit.library.IGate()\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.I:\n        return qml.I(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"id q[{qubits[0]}];\"\n</code></pre> <ol> <li> <p>Quantum info: The <code>quantum_info</code> folder contains objects and function for quantum information analysis.</p> </li> <li> <p>Circuits: The <code>circuits</code> folder contains more high-level objects to create and convert quantum circuits.</p> </li> </ol>"},{"location":"contributing/#pr-submission-guidelines","title":"PR submission guidelines","text":"<ul> <li>Keep each PR focused. While it's more convenient, do not combine several unrelated contributions together. It can be a good idea to split contributions into multiple PRs.</li> <li>Do not turn an already submitted PR into your development playground. If after you submitted a pull request you discovered that more work is needed - close the PR, do the required work and then submit a new PR. Otherwise each of your commits requires attention from maintainers of the project.</li> <li>Make sure to add tests for new features.</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<p>You can install <code>skq</code> using pip:</p> <pre><code>pip install -U skq\n</code></pre> <p>For development, you can clone the repository and install it in development mode:</p> <pre><code>git clone https://github.com/CarloLepelaars/skq.git\ncd skq\npip install -e \".[dev]\"\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#creating-quantum-gates","title":"Creating Quantum Gates","text":"<p><code>skq</code> provides a simple interface to create quantum gates. Under the hood, gates inherit from NumPy.</p> <pre><code>from skq.gates.qubit import H, X, Y, Z, I, CX, SWAP\n\n# Single-qubit gates\nh_gate = H()  # Hadamard gate\nx_gate = X()  # Pauli-X gate (NOT gate)\ny_gate = Y()  # Pauli-Y gate\nz_gate = Z()  # Pauli-Z gate\ni_gate = I()  # Identity gate\n\n# Multi-qubit gates\ncx_gate = CX()  # CNOT gate\nswap_gate = SWAP()  # SWAP gate\n\n# Convert gates to other frameworks\n# Qiskit\nh_gate_qiskit = h_gate.to_qiskit()\n# OpenQASM\nh_gate_qasm = h_gate.to_qasm()\n\n# Display the gate\n# ASCII\nh_gate.draw()\n# Matplotlib\nh_gate.draw(output=\"mpl\")\n</code></pre>"},{"location":"getting-started/#creating-quantum-circuits","title":"Creating Quantum Circuits","text":"<p>You can create quantum circuits by combining gates:</p> <pre><code>from skq.circuits import Circuit, Concat\nimport numpy as np\n\n# Create a Bell state circuit\nbell_circuit = Circuit([\n    Concat([H(), I()]),  # Apply H to first qubit, I to second qubit\n    CX()                 # Apply CNOT with first qubit as control\n])\n\n# Initial state |00\u27e9\ninitial_state = np.array([1, 0, 0, 0])\n\n# Run the circuit\nfinal_state = bell_circuit(initial_state)\nprint(final_state)\n# [0.70710678+0.j 0.        +0.j 0.        +0.j 0.70710678+0.j]\n</code></pre>"},{"location":"getting-started/#converting-to-other-frameworks","title":"Converting to Other Frameworks","text":"<p><code>skq</code> allows you to convert your circuits to other quantum computing frameworks:</p> <pre><code># Convert to Qiskit\nqiskit_circuit = bell_circuit.convert(framework=\"qiskit\")\nprint(qiskit_circuit.draw())\n\n# Convert to OpenQASM\nqasm_code = bell_circuit.convert(framework=\"qasm\")\nprint(qasm_code)\n</code></pre>"},{"location":"getting-started/#implementing-quantum-algorithms","title":"Implementing Quantum Algorithms","text":"<p><code>skq</code> includes implementations of common quantum algorithms:</p> <pre><code>from skq.circuits import Grover\nimport numpy as np\n\n# Create a Grover search circuit for 3 qubits\n# Searching for state |100\u27e9 (binary 4)\ntarget_state = np.zeros(8)\ntarget_state[4] = 1\n\ngrover_circuit = Grover().circuit(\n    n_qubits=3,\n    target_state=target_state,\n    n_iterations=1\n)\n\n# Run the circuit\ninitial_state = np.array([1, 0, 0, 0, 0, 0, 0, 0])  # |000\u27e9\nresult = grover_circuit(initial_state)\nprint(result)\n# The amplitude of state |100\u27e9 should be significantly higher\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn how to contribute to the project.</li> </ul>"},{"location":"api/base/","title":"Base Module API Reference","text":"<p>This page documents the base classes and functions in the <code>skq.base</code> module. These components form the foundation of the SKQ framework.</p>"},{"location":"api/base/#base-classes","title":"Base Classes","text":""},{"location":"api/base/#skq.base.Operator","title":"<code>skq.base.Operator</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>Base class for Quantum Operators. Gates, density matrices, hamiltonians, etc. are all operators. The operator must be a 2D matrix. :param input_array: Input array to create the operator. Will be converted to a NumPy array.</p> Source code in <code>src/skq/base.py</code> <pre><code>class Operator(np.ndarray):\n    \"\"\"\n    Base class for Quantum Operators.\n    Gates, density matrices, hamiltonians, etc. are all operators.\n    The operator must be a 2D matrix.\n    :param input_array: Input array to create the operator. Will be converted to a NumPy array.\n    \"\"\"\n\n    def __new__(cls, input_array):\n        arr = np.asarray(input_array, dtype=complex)\n        obj = arr.view(cls)\n        assert obj.is_2d(), \"Quantum operator must be a 2D matrix.\"\n        assert obj.is_square(), \"Quantum operator must be a square matrix.\"\n        assert obj.is_at_least_nxn(n=1), \"Gate must be at least a 1x1 matrix.\"\n        return obj\n\n    def encodes(self, other: np.ndarray) -&gt; bool:\n        \"\"\"Progress quantum state\"\"\"\n        return np.array(self @ other, dtype=complex)\n\n    def decodes(self, other: np.ndarray) -&gt; bool:\n        \"\"\"Reverse quantum state\"\"\"\n        return np.array(self.conjugate_transpose() @ other, dtype=complex)\n\n    def is_square(self) -&gt; bool:\n        \"\"\"Operator is a square matrix.\"\"\"\n        return self.shape[0] == self.shape[1]\n\n    def is_2d(self) -&gt; bool:\n        \"\"\"Operator is a 2D matrix.\"\"\"\n        return len(self.shape) == 2\n\n    def is_at_least_nxn(self, n: int) -&gt; bool:\n        \"\"\"Operator is at least an n x n matrix.\"\"\"\n        rows, cols = self.shape\n        return rows &gt;= n and cols &gt;= n\n\n    def is_power_of_n_shape(self, n: int) -&gt; bool:\n        \"\"\"\n        Operator shape is a power of n.\n        Qubits: n=2, Qutrits: n=3, Ququarts: n=4, Qupents: n=5, etc.\n        :param n: Number to check for power of n shape.\n        \"\"\"\n\n        def _is_power_of_n(x, n):\n            if x &lt; 1:\n                return False\n            while x % n == 0:\n                x //= n\n            return x == 1\n\n        rows, cols = self.shape\n        return _is_power_of_n(rows, n) and _is_power_of_n(cols, n)\n\n    def is_hermitian(self) -&gt; bool:\n        \"\"\"Check if the operator is Hermitian: U = U^dagger\"\"\"\n        return np.allclose(self, self.conjugate_transpose())\n\n    def is_identity(self) -&gt; bool:\n        \"\"\"Check if the operator is the identity matrix.\"\"\"\n        return np.allclose(self, np.eye(self.shape[0]))\n\n    def is_equal(self, other) -&gt; bool:\n        \"\"\"Check if the operator is effectively equal to another operator.\"\"\"\n        return np.allclose(self, other, atol=1e-8)\n\n    def num_levels(self) -&gt; int:\n        \"\"\"Number of rows. Used for checking valid shapes.\"\"\"\n        return self.shape[0]\n\n    def conjugate_transpose(self) -&gt; np.ndarray:\n        \"\"\"\n        Conjugate transpose (i.e. Hermitian adjoint or 'dagger operation') of the operator.\n        1. Transpose the matrix\n        2. Take the complex conjugate of each element (Flip the sign of the imaginary part)\n        \"\"\"\n        return self.T.conj()\n\n    def eigenvalues(self) -&gt; np.ndarray:\n        \"\"\"\n        Eigenvalues of the operator.\n        Hermitian operators use eigvalsh for stable and faster computation.\n        \"\"\"\n        return np.linalg.eigvalsh(self) if self.is_hermitian() else np.linalg.eigvals(self)\n\n    def eigenvectors(self) -&gt; np.ndarray:\n        \"\"\"\n        Eigenvectors of the operator.\n        Hermitian operators use eigh for stable and faster computation.\n        \"\"\"\n        return np.linalg.eigh(self)[1] if self.is_hermitian() else np.linalg.eig(self)[1]\n\n    def frobenius_norm(self) -&gt; float:\n        \"\"\"Compute the Frobenius norm\"\"\"\n        return np.linalg.norm(self)\n\n    def commute(self, other: \"Operator\") -&gt; bool:\n        \"\"\"\n        Check if operator commute. U and V commute if UV = VU.\n        :param other: Operator to check commutation with.\n        \"\"\"\n        assert isinstance(other, Operator), \"Other object must be a valid Operator.\"\n        assert self.num_levels() == other.num_levels(), \"Operators must have the same number of rows for the commutation check.\"\n        return np.allclose(self @ other, other @ self)\n\n    def to_qiskit(self) -&gt; qiskit.quantum_info.Operator:\n        \"\"\"Convert operator to a Qiskit.\"\"\"\n        raise NotImplementedError(f\"Conversion to Qiskit Gate is not implemented for {self.__class__.__name__}.\")\n\n    def from_qiskit(self, qiskit_operator: qiskit.quantum_info.Operator) -&gt; \"Operator\":\n        \"\"\"\n        Convert a Qiskit operator to scikit-q Operator.\n        :param qiskit_operator: Qiskit Operator\n        :return: scikit-q Operator object\n        \"\"\"\n        raise NotImplementedError(f\"Conversion from Qiskit is not implemented for {self.__class__.__name__}.\")\n\n    def to_pennylane(self):\n        \"\"\"Convert gate to a PennyLane gate object.\"\"\"\n        raise NotImplementedError(f\"Conversion to PennyLane is not implemented for {self.__class__.__name__}.\")\n\n    def from_pennylane(self, pennylane_operator: qml.operation.Operation) -&gt; \"Operator\":\n        \"\"\"\n        Convert a PennyLane Operation to scikit-q Operator.\n        :param pennylane_gate: PennyLane Operation object.\n        :return: scikit-q Operator\n        \"\"\"\n        raise NotImplementedError(f\"Conversion from PennyLane is not implemented for {self.__class__.__name__}.\")\n\n    def __call__(self, other: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Call the operator on a quantum state.\"\"\"\n        return self.encodes(other)\n</code></pre>"},{"location":"api/base/#skq.base.Operator.__call__","title":"<code>__call__(other)</code>","text":"<p>Call the operator on a quantum state.</p> Source code in <code>src/skq/base.py</code> <pre><code>def __call__(self, other: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Call the operator on a quantum state.\"\"\"\n    return self.encodes(other)\n</code></pre>"},{"location":"api/base/#skq.base.Operator.commute","title":"<code>commute(other)</code>","text":"<p>Check if operator commute. U and V commute if UV = VU. :param other: Operator to check commutation with.</p> Source code in <code>src/skq/base.py</code> <pre><code>def commute(self, other: \"Operator\") -&gt; bool:\n    \"\"\"\n    Check if operator commute. U and V commute if UV = VU.\n    :param other: Operator to check commutation with.\n    \"\"\"\n    assert isinstance(other, Operator), \"Other object must be a valid Operator.\"\n    assert self.num_levels() == other.num_levels(), \"Operators must have the same number of rows for the commutation check.\"\n    return np.allclose(self @ other, other @ self)\n</code></pre>"},{"location":"api/base/#skq.base.Operator.conjugate_transpose","title":"<code>conjugate_transpose()</code>","text":"<p>Conjugate transpose (i.e. Hermitian adjoint or 'dagger operation') of the operator. 1. Transpose the matrix 2. Take the complex conjugate of each element (Flip the sign of the imaginary part)</p> Source code in <code>src/skq/base.py</code> <pre><code>def conjugate_transpose(self) -&gt; np.ndarray:\n    \"\"\"\n    Conjugate transpose (i.e. Hermitian adjoint or 'dagger operation') of the operator.\n    1. Transpose the matrix\n    2. Take the complex conjugate of each element (Flip the sign of the imaginary part)\n    \"\"\"\n    return self.T.conj()\n</code></pre>"},{"location":"api/base/#skq.base.Operator.decodes","title":"<code>decodes(other)</code>","text":"<p>Reverse quantum state</p> Source code in <code>src/skq/base.py</code> <pre><code>def decodes(self, other: np.ndarray) -&gt; bool:\n    \"\"\"Reverse quantum state\"\"\"\n    return np.array(self.conjugate_transpose() @ other, dtype=complex)\n</code></pre>"},{"location":"api/base/#skq.base.Operator.eigenvalues","title":"<code>eigenvalues()</code>","text":"<p>Eigenvalues of the operator. Hermitian operators use eigvalsh for stable and faster computation.</p> Source code in <code>src/skq/base.py</code> <pre><code>def eigenvalues(self) -&gt; np.ndarray:\n    \"\"\"\n    Eigenvalues of the operator.\n    Hermitian operators use eigvalsh for stable and faster computation.\n    \"\"\"\n    return np.linalg.eigvalsh(self) if self.is_hermitian() else np.linalg.eigvals(self)\n</code></pre>"},{"location":"api/base/#skq.base.Operator.eigenvectors","title":"<code>eigenvectors()</code>","text":"<p>Eigenvectors of the operator. Hermitian operators use eigh for stable and faster computation.</p> Source code in <code>src/skq/base.py</code> <pre><code>def eigenvectors(self) -&gt; np.ndarray:\n    \"\"\"\n    Eigenvectors of the operator.\n    Hermitian operators use eigh for stable and faster computation.\n    \"\"\"\n    return np.linalg.eigh(self)[1] if self.is_hermitian() else np.linalg.eig(self)[1]\n</code></pre>"},{"location":"api/base/#skq.base.Operator.encodes","title":"<code>encodes(other)</code>","text":"<p>Progress quantum state</p> Source code in <code>src/skq/base.py</code> <pre><code>def encodes(self, other: np.ndarray) -&gt; bool:\n    \"\"\"Progress quantum state\"\"\"\n    return np.array(self @ other, dtype=complex)\n</code></pre>"},{"location":"api/base/#skq.base.Operator.frobenius_norm","title":"<code>frobenius_norm()</code>","text":"<p>Compute the Frobenius norm</p> Source code in <code>src/skq/base.py</code> <pre><code>def frobenius_norm(self) -&gt; float:\n    \"\"\"Compute the Frobenius norm\"\"\"\n    return np.linalg.norm(self)\n</code></pre>"},{"location":"api/base/#skq.base.Operator.from_pennylane","title":"<code>from_pennylane(pennylane_operator)</code>","text":"<p>Convert a PennyLane Operation to scikit-q Operator. :param pennylane_gate: PennyLane Operation object. :return: scikit-q Operator</p> Source code in <code>src/skq/base.py</code> <pre><code>def from_pennylane(self, pennylane_operator: qml.operation.Operation) -&gt; \"Operator\":\n    \"\"\"\n    Convert a PennyLane Operation to scikit-q Operator.\n    :param pennylane_gate: PennyLane Operation object.\n    :return: scikit-q Operator\n    \"\"\"\n    raise NotImplementedError(f\"Conversion from PennyLane is not implemented for {self.__class__.__name__}.\")\n</code></pre>"},{"location":"api/base/#skq.base.Operator.from_qiskit","title":"<code>from_qiskit(qiskit_operator)</code>","text":"<p>Convert a Qiskit operator to scikit-q Operator. :param qiskit_operator: Qiskit Operator :return: scikit-q Operator object</p> Source code in <code>src/skq/base.py</code> <pre><code>def from_qiskit(self, qiskit_operator: qiskit.quantum_info.Operator) -&gt; \"Operator\":\n    \"\"\"\n    Convert a Qiskit operator to scikit-q Operator.\n    :param qiskit_operator: Qiskit Operator\n    :return: scikit-q Operator object\n    \"\"\"\n    raise NotImplementedError(f\"Conversion from Qiskit is not implemented for {self.__class__.__name__}.\")\n</code></pre>"},{"location":"api/base/#skq.base.Operator.is_2d","title":"<code>is_2d()</code>","text":"<p>Operator is a 2D matrix.</p> Source code in <code>src/skq/base.py</code> <pre><code>def is_2d(self) -&gt; bool:\n    \"\"\"Operator is a 2D matrix.\"\"\"\n    return len(self.shape) == 2\n</code></pre>"},{"location":"api/base/#skq.base.Operator.is_at_least_nxn","title":"<code>is_at_least_nxn(n)</code>","text":"<p>Operator is at least an n x n matrix.</p> Source code in <code>src/skq/base.py</code> <pre><code>def is_at_least_nxn(self, n: int) -&gt; bool:\n    \"\"\"Operator is at least an n x n matrix.\"\"\"\n    rows, cols = self.shape\n    return rows &gt;= n and cols &gt;= n\n</code></pre>"},{"location":"api/base/#skq.base.Operator.is_equal","title":"<code>is_equal(other)</code>","text":"<p>Check if the operator is effectively equal to another operator.</p> Source code in <code>src/skq/base.py</code> <pre><code>def is_equal(self, other) -&gt; bool:\n    \"\"\"Check if the operator is effectively equal to another operator.\"\"\"\n    return np.allclose(self, other, atol=1e-8)\n</code></pre>"},{"location":"api/base/#skq.base.Operator.is_hermitian","title":"<code>is_hermitian()</code>","text":"<p>Check if the operator is Hermitian: U = U^dagger</p> Source code in <code>src/skq/base.py</code> <pre><code>def is_hermitian(self) -&gt; bool:\n    \"\"\"Check if the operator is Hermitian: U = U^dagger\"\"\"\n    return np.allclose(self, self.conjugate_transpose())\n</code></pre>"},{"location":"api/base/#skq.base.Operator.is_identity","title":"<code>is_identity()</code>","text":"<p>Check if the operator is the identity matrix.</p> Source code in <code>src/skq/base.py</code> <pre><code>def is_identity(self) -&gt; bool:\n    \"\"\"Check if the operator is the identity matrix.\"\"\"\n    return np.allclose(self, np.eye(self.shape[0]))\n</code></pre>"},{"location":"api/base/#skq.base.Operator.is_power_of_n_shape","title":"<code>is_power_of_n_shape(n)</code>","text":"<p>Operator shape is a power of n. Qubits: n=2, Qutrits: n=3, Ququarts: n=4, Qupents: n=5, etc. :param n: Number to check for power of n shape.</p> Source code in <code>src/skq/base.py</code> <pre><code>def is_power_of_n_shape(self, n: int) -&gt; bool:\n    \"\"\"\n    Operator shape is a power of n.\n    Qubits: n=2, Qutrits: n=3, Ququarts: n=4, Qupents: n=5, etc.\n    :param n: Number to check for power of n shape.\n    \"\"\"\n\n    def _is_power_of_n(x, n):\n        if x &lt; 1:\n            return False\n        while x % n == 0:\n            x //= n\n        return x == 1\n\n    rows, cols = self.shape\n    return _is_power_of_n(rows, n) and _is_power_of_n(cols, n)\n</code></pre>"},{"location":"api/base/#skq.base.Operator.is_square","title":"<code>is_square()</code>","text":"<p>Operator is a square matrix.</p> Source code in <code>src/skq/base.py</code> <pre><code>def is_square(self) -&gt; bool:\n    \"\"\"Operator is a square matrix.\"\"\"\n    return self.shape[0] == self.shape[1]\n</code></pre>"},{"location":"api/base/#skq.base.Operator.num_levels","title":"<code>num_levels()</code>","text":"<p>Number of rows. Used for checking valid shapes.</p> Source code in <code>src/skq/base.py</code> <pre><code>def num_levels(self) -&gt; int:\n    \"\"\"Number of rows. Used for checking valid shapes.\"\"\"\n    return self.shape[0]\n</code></pre>"},{"location":"api/base/#skq.base.Operator.to_pennylane","title":"<code>to_pennylane()</code>","text":"<p>Convert gate to a PennyLane gate object.</p> Source code in <code>src/skq/base.py</code> <pre><code>def to_pennylane(self):\n    \"\"\"Convert gate to a PennyLane gate object.\"\"\"\n    raise NotImplementedError(f\"Conversion to PennyLane is not implemented for {self.__class__.__name__}.\")\n</code></pre>"},{"location":"api/base/#skq.base.Operator.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert operator to a Qiskit.</p> Source code in <code>src/skq/base.py</code> <pre><code>def to_qiskit(self) -&gt; qiskit.quantum_info.Operator:\n    \"\"\"Convert operator to a Qiskit.\"\"\"\n    raise NotImplementedError(f\"Conversion to Qiskit Gate is not implemented for {self.__class__.__name__}.\")\n</code></pre>"},{"location":"api/base/#skq.base.HermitianOperator","title":"<code>skq.base.HermitianOperator</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Hermitian operator (observable) class. :param input_array: Input array to create the operator. Will be converted to a NumPy array.</p> Source code in <code>src/skq/base.py</code> <pre><code>class HermitianOperator(Operator):\n    \"\"\"\n    Hermitian operator (observable) class.\n    :param input_array: Input array to create the operator. Will be converted to a NumPy array.\n    \"\"\"\n\n    def __new__(cls, input_array):\n        obj = super().__new__(cls, input_array)\n        assert obj.is_hermitian(), \"Hermitian operator must be Hermitian.\"\n        assert obj.is_at_least_nxn(n=2), \"Hermitian operator must be at least a 2x2 matrix.\"\n        return obj\n</code></pre>"},{"location":"api/circuits/","title":"Circuits API Reference","text":"<p>This page documents the classes and functions available in the <code>skq.circuits</code> module. This module provides tools for creating and manipulating quantum circuits, as well as implementations of quantum algorithms.</p>"},{"location":"api/circuits/#circuit-building-blocks","title":"Circuit Building Blocks","text":""},{"location":"api/circuits/#circuit","title":"Circuit","text":""},{"location":"api/circuits/#skq.circuits.Circuit","title":"<code>skq.circuits.Circuit</code>","text":"<p>               Bases: <code>list</code></p> <p>Run multiple qubit gates in sequence.</p> Source code in <code>src/skq/circuits/circuit.py</code> <pre><code>class Circuit(list):\n    \"\"\"Run multiple qubit gates in sequence.\"\"\"\n\n    @property\n    def num_qubits(self) -&gt; int:\n        return max(g.num_qubits for g in self)\n\n    def encodes(self, x):\n        for gate in self:\n            x = gate.encodes(x)\n        return x\n\n    def decodes(self, x):\n        for gate in reversed(self):\n            x = gate.decodes(x)\n        return x\n\n    def __call__(self, x):\n        return self.encodes(x)\n\n    def convert(self, framework=\"qiskit\"):\n        \"\"\"Convert circuit to a given framework.\n        :param framework: Framework to convert to.\n        :return: Converter Circuit object.\n        For Qiskit -&gt; QuantumCircuit object.\n        For QASM -&gt; OpenQASM string.\n        \"\"\"\n        converter_mapping = {\"qiskit\": convert_to_qiskit, \"qasm\": convert_to_qasm}\n        assert framework in converter_mapping, f\"Invalid framework. Supported frameworks: {converter_mapping.keys()}.\"\n        return converter_mapping[framework](self)\n\n    def draw(self, **kwargs):\n        \"\"\"Draw circuit using Qiskit.\"\"\"\n        return self.convert(framework=\"qiskit\").draw(**kwargs)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.Circuit.convert","title":"<code>convert(framework='qiskit')</code>","text":"<p>Convert circuit to a given framework. :param framework: Framework to convert to. :return: Converter Circuit object. For Qiskit -&gt; QuantumCircuit object. For QASM -&gt; OpenQASM string.</p> Source code in <code>src/skq/circuits/circuit.py</code> <pre><code>def convert(self, framework=\"qiskit\"):\n    \"\"\"Convert circuit to a given framework.\n    :param framework: Framework to convert to.\n    :return: Converter Circuit object.\n    For Qiskit -&gt; QuantumCircuit object.\n    For QASM -&gt; OpenQASM string.\n    \"\"\"\n    converter_mapping = {\"qiskit\": convert_to_qiskit, \"qasm\": convert_to_qasm}\n    assert framework in converter_mapping, f\"Invalid framework. Supported frameworks: {converter_mapping.keys()}.\"\n    return converter_mapping[framework](self)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.Circuit.draw","title":"<code>draw(**kwargs)</code>","text":"<p>Draw circuit using Qiskit.</p> Source code in <code>src/skq/circuits/circuit.py</code> <pre><code>def draw(self, **kwargs):\n    \"\"\"Draw circuit using Qiskit.\"\"\"\n    return self.convert(framework=\"qiskit\").draw(**kwargs)\n</code></pre>"},{"location":"api/circuits/#concat","title":"Concat","text":"<pre><code>from skq.circuits import Circuit, Concat\nfrom skq.gates import H, I\n\n# Apply Hadamard to first qubit and Identity to second qubit\nparallel_gates = Concat([H(), I()])\n\n# Create a circuit with these parallel gates\ncircuit = Circuit([parallel_gates])\n</code></pre>"},{"location":"api/circuits/#skq.circuits.Concat","title":"<code>skq.circuits.Concat</code>","text":"<p>Combine multiple qubit gates into a single gate. :param gates: List of gates to concatenate.</p> Source code in <code>src/skq/circuits/circuit.py</code> <pre><code>class Concat:\n    \"\"\"\n    Combine multiple qubit gates into a single gate.\n    :param gates: List of gates to concatenate.\n    \"\"\"\n\n    def __init__(self, gates: list[Operator]):\n        assert len(gates) &gt; 1, \"Concat must have at least 2 gates.\"\n        assert all(isinstance(g, Operator) for g in gates), \"All gates must be instances of Operator.\"\n        self.gates = gates\n        self.encoding_matrix = reduce(np.kron, [g for g in gates])\n        self.num_qubits = sum(g.num_qubits for g in gates)\n\n    def encodes(self, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Concatenate 2 or more gates.\n\n        :param x: Quantum state to encode.\n        :return: Quantum state after encoding.\n        \"\"\"\n        return x @ self.encoding_matrix\n\n    def decodes(self, x: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Reverse propagation for all gates.\n\n        :param x: Quantum state to decode.\n        :return: Quantum state after decoding.\n        \"\"\"\n        for g in reversed(self.gates):\n            x = x @ np.kron(g.conj().T, np.eye(len(x) // g.shape[0]))\n        return x\n\n    def __call__(self, x):\n        return self.encodes(x)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.Concat.decodes","title":"<code>decodes(x)</code>","text":"<p>Reverse propagation for all gates.</p> <p>:param x: Quantum state to decode. :return: Quantum state after decoding.</p> Source code in <code>src/skq/circuits/circuit.py</code> <pre><code>def decodes(self, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Reverse propagation for all gates.\n\n    :param x: Quantum state to decode.\n    :return: Quantum state after decoding.\n    \"\"\"\n    for g in reversed(self.gates):\n        x = x @ np.kron(g.conj().T, np.eye(len(x) // g.shape[0]))\n    return x\n</code></pre>"},{"location":"api/circuits/#skq.circuits.Concat.encodes","title":"<code>encodes(x)</code>","text":"<p>Concatenate 2 or more gates.</p> <p>:param x: Quantum state to encode. :return: Quantum state after encoding.</p> Source code in <code>src/skq/circuits/circuit.py</code> <pre><code>def encodes(self, x: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Concatenate 2 or more gates.\n\n    :param x: Quantum state to encode.\n    :return: Quantum state after encoding.\n    \"\"\"\n    return x @ self.encoding_matrix\n</code></pre>"},{"location":"api/circuits/#quantum-algorithms","title":"Quantum Algorithms","text":""},{"location":"api/circuits/#bell-states","title":"Bell States","text":"<p>The <code>BellStates</code> class provides circuits for creating the four Bell states, which are maximally entangled two-qubit states.</p> <pre><code>from skq.circuits import BellStates\n\n# Create a circuit for the \u03a6+ Bell state (|00\u27e9 + |11\u27e9)/\u221a2\nbell_circuit = BellStates().circuit(configuration=1)\n\n# Create a circuit for the \u03a8- Bell state (|01\u27e9 - |10\u27e9)/\u221a2\nbell_circuit = BellStates().circuit(configuration=4)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.BellStates","title":"<code>skq.circuits.BellStates</code>","text":"<p>Convenience class for generating Bell States as skq Pipelines. More information on defining Bell States: - https://quantumcomputinguk.org/tutorials/introduction-to-bell-states - https://quantumcomputing.stackexchange.com/a/2260</p> Source code in <code>src/skq/circuits/entangled_states.py</code> <pre><code>class BellStates:\n    \"\"\"\n    Convenience class for generating Bell States as skq Pipelines.\n    More information on defining Bell States:\n    - https://quantumcomputinguk.org/tutorials/introduction-to-bell-states\n    - https://quantumcomputing.stackexchange.com/a/2260\n    \"\"\"\n\n    def circuit(self, configuration: int = 1) -&gt; Circuit:\n        \"\"\"\n        Return circuit for the Bell State based on the configuration.\n        :param configuration: Configuration of the Bell State.\n        Configuration 1: |\u03a6+\u27e9 =|00&gt; + |11&gt; / sqrt(2)\n        Configuration 2: |\u03a6-\u27e9 =|00&gt; - |11&gt; / sqrt(2)\n        Configuration 3: |\u03a8+\u27e9 =|01&gt; + |10&gt; / sqrt(2)\n        Configuration 4: |\u03a8-\u27e9 =|01&gt; - |10&gt; / sqrt(2)\n        :return: Circuit for the Bell State.\n        \"\"\"\n        assert configuration in [1, 2, 3, 4], f\"Invalid Bell State configuration: {configuration}. Configurations are: 1: |\u03a6+\u27e9, 2: |\u03a6-\u27e9, 3: |\u03a8+\u27e9, 4: |\u03a8-\u27e9\"\n        config_mapping = {\n            1: self.omega_plus,\n            2: self.omega_minus,\n            3: self.phi_plus,\n            4: self.phi_minus,\n        }\n        pipe = config_mapping[configuration]()\n        return pipe\n\n    def omega_plus(self) -&gt; Circuit:\n        \"\"\"\n        Return circuit for the entangled state |\u03a6+\u27e9 =|00&gt; + |11&gt; / sqrt(2).\n        This corresponds to the 1st bell state.\n        :return: Circuit for creating the 1st Bell State.\n        \"\"\"\n        return Circuit([Concat([H(), I()]), CX()])\n\n    def omega_minus(self) -&gt; Circuit:\n        \"\"\"\n        Return circuit for the entangled state |\u03a6\u2212\u27e9 =|00&gt; - |11&gt; / sqrt(2).\n        This corresponds to the 2nd bell state.\n        :return: Circuit for creating the 2nd Bell State\n\n        \"\"\"\n        return Circuit([Concat([H(), I()]), CX(), Concat([Z(), I()])])\n\n    def phi_plus(self) -&gt; Circuit:\n        \"\"\"\n        Return circuit for the entangled state  |\u03a8+\u27e9 =|01&gt; + |10&gt; / sqrt(2).\n        This corresponds to the 3rd bell state.\n        :return: Circuit for creating the 3rd Bell State\n        \"\"\"\n        return Circuit([Concat([H(), X()]), CX()])\n\n    def phi_minus(self) -&gt; Circuit:\n        \"\"\"\n        Return circuit for the entangled state |\u03a8\u2212\u27e9 =|01&gt; - |10&gt; / sqrt(2).\n        This corresponds to the 4th bell state.\n        :return: Circuit for creating the 4th Bell State\n        \"\"\"\n        return Circuit([Concat([H(), X()]), Concat([Z(), Z()]), CX()])\n</code></pre>"},{"location":"api/circuits/#skq.circuits.BellStates.circuit","title":"<code>circuit(configuration=1)</code>","text":"<p>Return circuit for the Bell State based on the configuration. :param configuration: Configuration of the Bell State. Configuration 1: |\u03a6+\u27e9 =|00&gt; + |11&gt; / sqrt(2) Configuration 2: |\u03a6-\u27e9 =|00&gt; - |11&gt; / sqrt(2) Configuration 3: |\u03a8+\u27e9 =|01&gt; + |10&gt; / sqrt(2) Configuration 4: |\u03a8-\u27e9 =|01&gt; - |10&gt; / sqrt(2) :return: Circuit for the Bell State.</p> Source code in <code>src/skq/circuits/entangled_states.py</code> <pre><code>def circuit(self, configuration: int = 1) -&gt; Circuit:\n    \"\"\"\n    Return circuit for the Bell State based on the configuration.\n    :param configuration: Configuration of the Bell State.\n    Configuration 1: |\u03a6+\u27e9 =|00&gt; + |11&gt; / sqrt(2)\n    Configuration 2: |\u03a6-\u27e9 =|00&gt; - |11&gt; / sqrt(2)\n    Configuration 3: |\u03a8+\u27e9 =|01&gt; + |10&gt; / sqrt(2)\n    Configuration 4: |\u03a8-\u27e9 =|01&gt; - |10&gt; / sqrt(2)\n    :return: Circuit for the Bell State.\n    \"\"\"\n    assert configuration in [1, 2, 3, 4], f\"Invalid Bell State configuration: {configuration}. Configurations are: 1: |\u03a6+\u27e9, 2: |\u03a6-\u27e9, 3: |\u03a8+\u27e9, 4: |\u03a8-\u27e9\"\n    config_mapping = {\n        1: self.omega_plus,\n        2: self.omega_minus,\n        3: self.phi_plus,\n        4: self.phi_minus,\n    }\n    pipe = config_mapping[configuration]()\n    return pipe\n</code></pre>"},{"location":"api/circuits/#skq.circuits.BellStates.omega_minus","title":"<code>omega_minus()</code>","text":"<p>Return circuit for the entangled state |\u03a6\u2212\u27e9 =|00&gt; - |11&gt; / sqrt(2). This corresponds to the 2nd bell state. :return: Circuit for creating the 2nd Bell State</p> Source code in <code>src/skq/circuits/entangled_states.py</code> <pre><code>def omega_minus(self) -&gt; Circuit:\n    \"\"\"\n    Return circuit for the entangled state |\u03a6\u2212\u27e9 =|00&gt; - |11&gt; / sqrt(2).\n    This corresponds to the 2nd bell state.\n    :return: Circuit for creating the 2nd Bell State\n\n    \"\"\"\n    return Circuit([Concat([H(), I()]), CX(), Concat([Z(), I()])])\n</code></pre>"},{"location":"api/circuits/#skq.circuits.BellStates.omega_plus","title":"<code>omega_plus()</code>","text":"<p>Return circuit for the entangled state |\u03a6+\u27e9 =|00&gt; + |11&gt; / sqrt(2). This corresponds to the 1st bell state. :return: Circuit for creating the 1st Bell State.</p> Source code in <code>src/skq/circuits/entangled_states.py</code> <pre><code>def omega_plus(self) -&gt; Circuit:\n    \"\"\"\n    Return circuit for the entangled state |\u03a6+\u27e9 =|00&gt; + |11&gt; / sqrt(2).\n    This corresponds to the 1st bell state.\n    :return: Circuit for creating the 1st Bell State.\n    \"\"\"\n    return Circuit([Concat([H(), I()]), CX()])\n</code></pre>"},{"location":"api/circuits/#skq.circuits.BellStates.phi_minus","title":"<code>phi_minus()</code>","text":"<p>Return circuit for the entangled state |\u03a8\u2212\u27e9 =|01&gt; - |10&gt; / sqrt(2). This corresponds to the 4th bell state. :return: Circuit for creating the 4th Bell State</p> Source code in <code>src/skq/circuits/entangled_states.py</code> <pre><code>def phi_minus(self) -&gt; Circuit:\n    \"\"\"\n    Return circuit for the entangled state |\u03a8\u2212\u27e9 =|01&gt; - |10&gt; / sqrt(2).\n    This corresponds to the 4th bell state.\n    :return: Circuit for creating the 4th Bell State\n    \"\"\"\n    return Circuit([Concat([H(), X()]), Concat([Z(), Z()]), CX()])\n</code></pre>"},{"location":"api/circuits/#skq.circuits.BellStates.phi_plus","title":"<code>phi_plus()</code>","text":"<p>Return circuit for the entangled state  |\u03a8+\u27e9 =|01&gt; + |10&gt; / sqrt(2). This corresponds to the 3rd bell state. :return: Circuit for creating the 3rd Bell State</p> Source code in <code>src/skq/circuits/entangled_states.py</code> <pre><code>def phi_plus(self) -&gt; Circuit:\n    \"\"\"\n    Return circuit for the entangled state  |\u03a8+\u27e9 =|01&gt; + |10&gt; / sqrt(2).\n    This corresponds to the 3rd bell state.\n    :return: Circuit for creating the 3rd Bell State\n    \"\"\"\n    return Circuit([Concat([H(), X()]), CX()])\n</code></pre>"},{"location":"api/circuits/#ghz-states","title":"GHZ States","text":"<p>The <code>GHZStates</code> class provides circuits for creating Greenberger-Horne-Zeilinger (GHZ) states, which are multi-qubit generalizations of Bell states.</p> <pre><code>from skq.circuits import GHZStates\n\n# Create a circuit for a 3-qubit GHZ state (|000\u27e9 + |111\u27e9)/\u221a2\nghz_circuit = GHZStates().circuit(n_qubits=3)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.GHZStates","title":"<code>skq.circuits.GHZStates</code>","text":"<p>Generalization of Bell States to 3 or more qubits. Greenberger-Horne-Zeilinger (GHZ) states.</p> Source code in <code>src/skq/circuits/entangled_states.py</code> <pre><code>class GHZStates:\n    \"\"\"\n    Generalization of Bell States to 3 or more qubits.\n    Greenberger-Horne-Zeilinger (GHZ) states.\n    \"\"\"\n\n    def circuit(self, n_qubits: int) -&gt; Circuit:\n        \"\"\"\n        :param n_qubits: Number of qubits in the GHZ state.\n        :return: Circuit for the GHZ state.\n        \"\"\"\n        assert n_qubits &gt; 2, \"GHZ state requires at least 3 qubits\"\n        return Circuit([Concat([H()] + [I()] * (n_qubits - 1)), *[Concat([I()] * i + [CX()] + [I()] * (n_qubits - i - 2)) for i in range(n_qubits - 1)]])\n</code></pre>"},{"location":"api/circuits/#skq.circuits.GHZStates.circuit","title":"<code>circuit(n_qubits)</code>","text":"<p>:param n_qubits: Number of qubits in the GHZ state. :return: Circuit for the GHZ state.</p> Source code in <code>src/skq/circuits/entangled_states.py</code> <pre><code>def circuit(self, n_qubits: int) -&gt; Circuit:\n    \"\"\"\n    :param n_qubits: Number of qubits in the GHZ state.\n    :return: Circuit for the GHZ state.\n    \"\"\"\n    assert n_qubits &gt; 2, \"GHZ state requires at least 3 qubits\"\n    return Circuit([Concat([H()] + [I()] * (n_qubits - 1)), *[Concat([I()] * i + [CX()] + [I()] * (n_qubits - i - 2)) for i in range(n_qubits - 1)]])\n</code></pre>"},{"location":"api/circuits/#w-state","title":"W State","text":"<p>The <code>WState</code> class provides a circuit for creating the 3-qubit W state, which is another type of entangled state.</p> <pre><code>from skq.circuits import WState\n\n# Create a circuit for the W state (|001\u27e9 + |010\u27e9 + |100\u27e9)/\u221a3\nw_circuit = WState().circuit()\n</code></pre>"},{"location":"api/circuits/#skq.circuits.WState","title":"<code>skq.circuits.WState</code>","text":"<p>3-qubit W State: (|001\u27e9 + |010\u27e9 + |100\u27e9)/\u221a3</p> Source code in <code>src/skq/circuits/entangled_states.py</code> <pre><code>class WState:\n    \"\"\"3-qubit W State: (|001\u27e9 + |010\u27e9 + |100\u27e9)/\u221a3\"\"\"\n\n    def circuit(self) -&gt; Circuit:\n        theta = -2 * np.arccos(1 / np.sqrt(3))\n        return Circuit(\n            [\n                Concat([RY(theta), I(), I()]),\n                Concat([CH(), I()]),\n                Concat([I(), CX()]),\n                Concat([CX(), I()]),\n                Concat([X(), I(), I()]),\n            ]\n        )\n</code></pre>"},{"location":"api/circuits/#deutschs-algorithm","title":"Deutsch's Algorithm","text":"<p>The <code>Deutsch</code> class implements Deutsch's algorithm, which determines whether a function is constant or balanced with a single query.</p> <pre><code>from skq.circuits import Deutsch\n\n# Define a constant function (always returns 0)\ndef constant_function(x):\n    return 0\n\n# Create a circuit for Deutsch's algorithm\ndeutsch_circuit = Deutsch().circuit(f=constant_function)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.Deutsch","title":"<code>skq.circuits.Deutsch</code>","text":"<p>Deutsch's algorithm.</p> Source code in <code>src/skq/circuits/deutsch.py</code> <pre><code>class Deutsch:\n    \"\"\"Deutsch's algorithm.\"\"\"\n\n    def circuit(self, f: Callable, measure: bool = True) -&gt; Circuit:\n        \"\"\"\n        Deutsch's algorithm\n        :param f: Binary function that maps a single bit to a single bit.\n        :param measure: Whether to measure the qubits.\n        :return: skq Circuit that implements Deutsch's algorithm.\n        \"\"\"\n        circuit = [\n            Concat([I(), X()]),\n            Concat([H(), H()]),\n            DeutschOracle(f),\n            Concat([H(), I()]),\n        ]\n        if measure:\n            circuit.append(Measure())\n        return Circuit(circuit)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.Deutsch.circuit","title":"<code>circuit(f, measure=True)</code>","text":"<p>Deutsch's algorithm :param f: Binary function that maps a single bit to a single bit. :param measure: Whether to measure the qubits. :return: skq Circuit that implements Deutsch's algorithm.</p> Source code in <code>src/skq/circuits/deutsch.py</code> <pre><code>def circuit(self, f: Callable, measure: bool = True) -&gt; Circuit:\n    \"\"\"\n    Deutsch's algorithm\n    :param f: Binary function that maps a single bit to a single bit.\n    :param measure: Whether to measure the qubits.\n    :return: skq Circuit that implements Deutsch's algorithm.\n    \"\"\"\n    circuit = [\n        Concat([I(), X()]),\n        Concat([H(), H()]),\n        DeutschOracle(f),\n        Concat([H(), I()]),\n    ]\n    if measure:\n        circuit.append(Measure())\n    return Circuit(circuit)\n</code></pre>"},{"location":"api/circuits/#deutsch-jozsa-algorithm","title":"Deutsch-Jozsa Algorithm","text":"<p>The <code>DeutschJozsa</code> class implements the Deutsch-Jozsa algorithm, which is a generalization of Deutsch's algorithm to multiple qubits.</p> <pre><code>from skq.circuits import DeutschJozsa\n\n# Define a constant function for multiple bits\ndef constant_function(x):\n    return 0\n\n# Create a circuit for the Deutsch-Jozsa algorithm with 3 qubits\ndj_circuit = DeutschJozsa().circuit(f=constant_function, n_bits=3)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.DeutschJozsa","title":"<code>skq.circuits.DeutschJozsa</code>","text":"<p>Deutsch-Jozsa algorithm.</p> Source code in <code>src/skq/circuits/deutsch.py</code> <pre><code>class DeutschJozsa:\n    \"\"\"Deutsch-Jozsa algorithm.\"\"\"\n\n    def circuit(self, f: Callable, n_bits: int, measure: bool = True) -&gt; Circuit:\n        \"\"\"\n        Deutsch-Josza algorithm\n        :param f: Binary function that maps a single bit to a single bit.\n        :return: skq Circuit that implements Deutsch-Josza algorithm.\n        \"\"\"\n        circuit = [\n            Concat([I() for _ in range(n_bits - 1)] + [X()]),\n            Concat([H() for _ in range(n_bits)]),\n            DeutschJozsaOracle(f, n_bits=n_bits),\n            Concat([H() for _ in range(n_bits)]),\n        ]\n        if measure:\n            circuit.append(Measure())\n        return Circuit(circuit)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.DeutschJozsa.circuit","title":"<code>circuit(f, n_bits, measure=True)</code>","text":"<p>Deutsch-Josza algorithm :param f: Binary function that maps a single bit to a single bit. :return: skq Circuit that implements Deutsch-Josza algorithm.</p> Source code in <code>src/skq/circuits/deutsch.py</code> <pre><code>def circuit(self, f: Callable, n_bits: int, measure: bool = True) -&gt; Circuit:\n    \"\"\"\n    Deutsch-Josza algorithm\n    :param f: Binary function that maps a single bit to a single bit.\n    :return: skq Circuit that implements Deutsch-Josza algorithm.\n    \"\"\"\n    circuit = [\n        Concat([I() for _ in range(n_bits - 1)] + [X()]),\n        Concat([H() for _ in range(n_bits)]),\n        DeutschJozsaOracle(f, n_bits=n_bits),\n        Concat([H() for _ in range(n_bits)]),\n    ]\n    if measure:\n        circuit.append(Measure())\n    return Circuit(circuit)\n</code></pre>"},{"location":"api/circuits/#grovers-algorithm","title":"Grover's Algorithm","text":"<p>The <code>Grover</code> class implements Grover's search algorithm, which can find a marked item in an unsorted database quadratically faster than classical algorithms.</p> <pre><code>from skq.circuits import Grover\nimport numpy as np\n\n# Create a target state to search for (|100\u27e9)\ntarget_state = np.zeros(8)\ntarget_state[4] = 1\n\n# Create a circuit for Grover's algorithm\ngrover_circuit = Grover().circuit(\n    target_state=target_state,\n    n_qubits=3,\n    n_iterations=1\n)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.Grover","title":"<code>skq.circuits.Grover</code>","text":"<p>Grover's search algorithm.</p> Source code in <code>src/skq/circuits/grover.py</code> <pre><code>class Grover:\n    \"\"\"\n    Grover's search algorithm.\n    \"\"\"\n\n    def circuit(self, target_state: np.array, n_qubits: int, n_iterations: int, measure: bool = True) -&gt; Circuit:\n        \"\"\"\n        Grover's search algorithm\n        :param target_state: Target state to search for.\n        :param n_qubits: Number of qubits in the circuit.\n        :param n_iterations: Number of Grover iterations to perform.\n        :param measure: Whether to measure the qubits.\n        :return: Circuit for the Grover search algorithm.\n        \"\"\"\n        single_grover_iteration = [PhaseOracle(target_state), GroverDiffusion(n_qubits=n_qubits)]\n        equal_superposition = Concat([H() for _ in range(n_qubits)])\n        steps = [equal_superposition, *[gate for _ in range(n_iterations) for gate in single_grover_iteration]]\n        if measure:\n            steps.append(Measure())\n        return Circuit(steps)\n</code></pre>"},{"location":"api/circuits/#skq.circuits.Grover.circuit","title":"<code>circuit(target_state, n_qubits, n_iterations, measure=True)</code>","text":"<p>Grover's search algorithm :param target_state: Target state to search for. :param n_qubits: Number of qubits in the circuit. :param n_iterations: Number of Grover iterations to perform. :param measure: Whether to measure the qubits. :return: Circuit for the Grover search algorithm.</p> Source code in <code>src/skq/circuits/grover.py</code> <pre><code>def circuit(self, target_state: np.array, n_qubits: int, n_iterations: int, measure: bool = True) -&gt; Circuit:\n    \"\"\"\n    Grover's search algorithm\n    :param target_state: Target state to search for.\n    :param n_qubits: Number of qubits in the circuit.\n    :param n_iterations: Number of Grover iterations to perform.\n    :param measure: Whether to measure the qubits.\n    :return: Circuit for the Grover search algorithm.\n    \"\"\"\n    single_grover_iteration = [PhaseOracle(target_state), GroverDiffusion(n_qubits=n_qubits)]\n    equal_superposition = Concat([H() for _ in range(n_qubits)])\n    steps = [equal_superposition, *[gate for _ in range(n_iterations) for gate in single_grover_iteration]]\n    if measure:\n        steps.append(Measure())\n    return Circuit(steps)\n</code></pre>"},{"location":"api/circuits/#circuit-conversion","title":"Circuit Conversion","text":"<p>SKQ circuits can be converted to other quantum computing frameworks:</p> <pre><code>from skq.circuits import Circuit, Concat\nfrom skq.gates import H, I, CX\n\n# Create a Bell state circuit\nbell_circuit = Circuit([\n    Concat([H(), I()]),  # Apply H to first qubit, I to second qubit\n    CX()                 # Apply CNOT with first qubit as control\n])\n\n# Convert to Qiskit\nqiskit_circuit = bell_circuit.convert(framework=\"qiskit\")\n\n# Convert to OpenQASM\nqasm_code = bell_circuit.convert(framework=\"qasm\")\n</code></pre>"},{"location":"api/circuits/#skq.circuits.convert_to_qiskit","title":"<code>skq.circuits.convert_to_qiskit(circuit)</code>","text":"<p>Convert a skq Circuit into a Qiskit QuantumCircuit.</p> Source code in <code>src/skq/circuits/circuit.py</code> <pre><code>def convert_to_qiskit(circuit: Circuit) -&gt; QuantumCircuit:\n    \"\"\"Convert a skq Circuit into a Qiskit QuantumCircuit.\"\"\"\n\n    def handle_gate(qc, gate, start_idx=None):\n        if isinstance(gate, I):\n            return\n        if isinstance(gate, Measure):\n            for q in range(circuit.num_qubits):\n                qc.measure(q, q)\n            return\n        # Create list of consecutive qubit indices starting from start_idx\n        qubits = list(range(start_idx, start_idx + gate.num_qubits)) if start_idx is not None else list(range(gate.num_qubits))\n        qc.append(gate.to_qiskit(), qubits)\n\n    qc = QuantumCircuit(circuit.num_qubits, circuit.num_qubits if any(isinstance(g, Measure) for g in circuit) else 0)\n\n    for gate in circuit:\n        if isinstance(gate, Concat):\n            offset = 0\n            for sub_gate in gate.gates:\n                handle_gate(qc, sub_gate, offset)\n                offset += sub_gate.num_qubits\n        else:\n            handle_gate(qc, gate)\n    return qc\n</code></pre>"},{"location":"api/circuits/#skq.circuits.convert_to_qasm","title":"<code>skq.circuits.convert_to_qasm(circuit)</code>","text":"<p>Convert a skq Circuit into an OpenQASM string.</p> Source code in <code>src/skq/circuits/circuit.py</code> <pre><code>def convert_to_qasm(circuit: Circuit) -&gt; str:\n    \"\"\"Convert a skq Circuit into an OpenQASM string.\"\"\"\n    qasm_lines = [\n        \"OPENQASM 2.0;\",  # OpenQASM header\n        'include \"qelib1.inc\";',  # Standard library\n        f\"qreg q[{circuit.num_qubits}];\",  # Declare quantum register\n    ]\n    # Declare classical register if measurement is present\n    if any(isinstance(g, Measure) for g in circuit):\n        qasm_lines.append(f\"creg c[{circuit.num_qubits}];\")\n\n    def handle_gate(gate, start_idx=None):\n        if isinstance(gate, I):\n            return []\n        if isinstance(gate, Measure):\n            return [f\"measure q[{q}] -&gt; c[{q}];\" for q in range(circuit.num_qubits)]\n        # Create list of consecutive qubit indices starting from start_idx\n        qubits = list(range(start_idx, start_idx + gate.num_qubits)) if start_idx is not None else list(range(gate.num_qubits))\n        return [gate.to_qasm(qubits)]\n\n    for gate in circuit:\n        if isinstance(gate, Concat):\n            offset = 0\n            for sub_gate in gate.gates:\n                qasm_lines.extend(handle_gate(sub_gate, offset))\n                offset += sub_gate.num_qubits\n        else:\n            qasm_lines.extend(handle_gate(gate))\n    return \"\\n\".join(qasm_lines)\n</code></pre>"},{"location":"api/constants/","title":"Constants API Reference","text":"<p>This page documents the constants available in the <code>skq.constants</code> module. These constants are used throughout the SKQ framework.</p>"},{"location":"api/constants/#physical-constants","title":"Physical Constants","text":""},{"location":"api/constants/#planck_constant","title":"PLANCK_CONSTANT","text":"<p>Planck constant in J\u00b7s (joule-seconds).</p> <p>Value: 6.62607015 \u00d7 10^-34 J\u00b7s</p> <pre><code>from skq.constants import PLANCK_CONSTANT\n\nprint(PLANCK_CONSTANT)  # 6.62607015e-34\n</code></pre>"},{"location":"api/constants/#reduced_planck_constant","title":"REDUCED_PLANCK_CONSTANT","text":"<p>Reduced Planck constant (\u0127) in J\u00b7s (joule-seconds).</p> <p>Value: 1.054571817 \u00d7 10^-34 J\u00b7s</p> <pre><code>from skq.constants import REDUCED_PLANCK_CONSTANT\n\nprint(REDUCED_PLANCK_CONSTANT)  # 1.054571817e-34\n</code></pre>"},{"location":"api/constants/#boltzmann_constant","title":"BOLTZMANN_CONSTANT","text":"<p>Boltzmann constant in J/K (joules per kelvin).</p> <p>Value: 1.380649 \u00d7 10^-23 J/K</p> <pre><code>from skq.constants import BOLTZMANN_CONSTANT\n\nprint(BOLTZMANN_CONSTANT)  # 1.380649e-23\n</code></pre>"},{"location":"api/constants/#speed_of_light","title":"SPEED_OF_LIGHT","text":"<p>Speed of light in vacuum in m/s (meters per second).</p> <p>Value: 2.99792458 \u00d7 10^8 m/s</p> <pre><code>from skq.constants import SPEED_OF_LIGHT\n\nprint(SPEED_OF_LIGHT)  # 299792458.0\n</code></pre>"},{"location":"api/constants/#electron_charge","title":"ELECTRON_CHARGE","text":"<p>Elementary charge (charge of an electron) in C (coulombs).</p> <p>Value: 1.602176634 \u00d7 10^-19 C</p> <pre><code>from skq.constants import ELECTRON_CHARGE\n\nprint(ELECTRON_CHARGE)  # 1.602176634e-19\n</code></pre>"},{"location":"api/constants/#permeability_of_free_space","title":"PERMEABILITY_OF_FREE_SPACE","text":"<p>Permeability of free space (vacuum permeability) in N/A\u00b2 (newtons per ampere squared).</p> <p>Value: 4\u03c0 \u00d7 10^-7 N/A\u00b2</p> <pre><code>from skq.constants import PERMEABILITY_OF_FREE_SPACE\nimport numpy as np\n\nprint(PERMEABILITY_OF_FREE_SPACE)  # 1.2566370614359173e-06 (4\u03c0 \u00d7 10^-7)\nprint(PERMEABILITY_OF_FREE_SPACE == 4 * np.pi * 1e-7)  # True\n</code></pre>"},{"location":"api/constants/#permittivity_of_free_space","title":"PERMITTIVITY_OF_FREE_SPACE","text":"<p>Permittivity of free space (vacuum permittivity) in F/m (farads per meter).</p> <p>Value: 8.854187817 \u00d7 10^-12 F/m</p> <pre><code>from skq.constants import PERMITTIVITY_OF_FREE_SPACE\n\nprint(PERMITTIVITY_OF_FREE_SPACE)  # 8.854187817e-12\n</code></pre>"},{"location":"api/constants/#skq.constants","title":"<code>skq.constants</code>","text":""},{"location":"api/gates-base/","title":"Gates Base API Reference","text":"<p>This page documents the base classes available in the <code>skq.gates</code> module.</p>"},{"location":"api/gates-base/#base-gate","title":"Base Gate","text":"<p>The <code>BaseGate</code> class serves as the foundation for all quantum gates in SKQ.</p>"},{"location":"api/gates-base/#skq.gates.base.BaseGate","title":"<code>skq.gates.base.BaseGate</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Base class for quantum gates of any computational basis. The gate must be a 2D unitary matrix. :param input_array: Input array to create the gate. Will be converted to a NumPy array.</p> Source code in <code>src/skq/gates/base.py</code> <pre><code>class BaseGate(Operator):\n    \"\"\"\n    Base class for quantum gates of any computational basis.\n    The gate must be a 2D unitary matrix.\n    :param input_array: Input array to create the gate. Will be converted to a NumPy array.\n    \"\"\"\n\n    def __new__(cls, input_array) -&gt; \"BaseGate\":\n        obj = super().__new__(cls, input_array)\n        assert obj.is_unitary(), \"Gate must be unitary.\"\n        return obj\n\n    def is_unitary(self) -&gt; bool:\n        \"\"\"Check if the gate is unitary (U*U^dagger = I)\"\"\"\n        identity = np.eye(self.shape[0])\n        return np.allclose(self @ self.conjugate_transpose(), identity)\n\n    def kernel_density(self, other: \"BaseGate\") -&gt; complex:\n        \"\"\"\n        Calculate the quantum kernel using density matrices.\n        The kernel is defined as Tr(U * V).\n        :param other: Gate object to compute the kernel with.\n        :return kernel: Complex number representing the kernel density.\n        \"\"\"\n        assert isinstance(other, BaseGate), \"Other object must be an instance of BaseUnitary (i.e. a Unitary matrix).\"\n        assert self.num_levels() == other.num_levels(), \"Gates must have the same number of rows for the kernel density.\"\n        return np.trace(self @ other)\n\n    def hilbert_schmidt_inner_product(self, other: \"BaseGate\") -&gt; complex:\n        \"\"\"\n        Calculate the Hilbert-Schmidt inner product with another gate.\n        The inner product is Tr(U^dagger * V).\n        :param other: Gate object to compute the inner product with.\n        :return inner_product: Complex number representing the inner product.\n        \"\"\"\n        assert isinstance(other, BaseGate), \"Other object must be an instance of BaseUnitary (i.e. a Unitary matrix).\"\n        assert self.num_levels() == other.num_levels(), \"Gates must have the same number of rows for the Hilbert-Schmidt inner product.\"\n        return np.trace(self.conjugate_transpose() @ other)\n\n    def convert_endianness(self) -&gt; \"BaseGate\":\n        \"\"\"Convert a gate matrix from big-endian to little-endian and vice versa.\"\"\"\n        num_qubits = self.num_qubits\n        perm = np.argsort([int(bin(i)[2:].zfill(num_qubits)[::-1], 2) for i in range(2**num_qubits)])\n        return self[np.ix_(perm, perm)]\n</code></pre>"},{"location":"api/gates-base/#skq.gates.base.BaseGate.convert_endianness","title":"<code>convert_endianness()</code>","text":"<p>Convert a gate matrix from big-endian to little-endian and vice versa.</p> Source code in <code>src/skq/gates/base.py</code> <pre><code>def convert_endianness(self) -&gt; \"BaseGate\":\n    \"\"\"Convert a gate matrix from big-endian to little-endian and vice versa.\"\"\"\n    num_qubits = self.num_qubits\n    perm = np.argsort([int(bin(i)[2:].zfill(num_qubits)[::-1], 2) for i in range(2**num_qubits)])\n    return self[np.ix_(perm, perm)]\n</code></pre>"},{"location":"api/gates-base/#skq.gates.base.BaseGate.hilbert_schmidt_inner_product","title":"<code>hilbert_schmidt_inner_product(other)</code>","text":"<p>Calculate the Hilbert-Schmidt inner product with another gate. The inner product is Tr(U^dagger * V). :param other: Gate object to compute the inner product with. :return inner_product: Complex number representing the inner product.</p> Source code in <code>src/skq/gates/base.py</code> <pre><code>def hilbert_schmidt_inner_product(self, other: \"BaseGate\") -&gt; complex:\n    \"\"\"\n    Calculate the Hilbert-Schmidt inner product with another gate.\n    The inner product is Tr(U^dagger * V).\n    :param other: Gate object to compute the inner product with.\n    :return inner_product: Complex number representing the inner product.\n    \"\"\"\n    assert isinstance(other, BaseGate), \"Other object must be an instance of BaseUnitary (i.e. a Unitary matrix).\"\n    assert self.num_levels() == other.num_levels(), \"Gates must have the same number of rows for the Hilbert-Schmidt inner product.\"\n    return np.trace(self.conjugate_transpose() @ other)\n</code></pre>"},{"location":"api/gates-base/#skq.gates.base.BaseGate.is_unitary","title":"<code>is_unitary()</code>","text":"<p>Check if the gate is unitary (U*U^dagger = I)</p> Source code in <code>src/skq/gates/base.py</code> <pre><code>def is_unitary(self) -&gt; bool:\n    \"\"\"Check if the gate is unitary (U*U^dagger = I)\"\"\"\n    identity = np.eye(self.shape[0])\n    return np.allclose(self @ self.conjugate_transpose(), identity)\n</code></pre>"},{"location":"api/gates-base/#skq.gates.base.BaseGate.kernel_density","title":"<code>kernel_density(other)</code>","text":"<p>Calculate the quantum kernel using density matrices. The kernel is defined as Tr(U * V). :param other: Gate object to compute the kernel with. :return kernel: Complex number representing the kernel density.</p> Source code in <code>src/skq/gates/base.py</code> <pre><code>def kernel_density(self, other: \"BaseGate\") -&gt; complex:\n    \"\"\"\n    Calculate the quantum kernel using density matrices.\n    The kernel is defined as Tr(U * V).\n    :param other: Gate object to compute the kernel with.\n    :return kernel: Complex number representing the kernel density.\n    \"\"\"\n    assert isinstance(other, BaseGate), \"Other object must be an instance of BaseUnitary (i.e. a Unitary matrix).\"\n    assert self.num_levels() == other.num_levels(), \"Gates must have the same number of rows for the kernel density.\"\n    return np.trace(self @ other)\n</code></pre>"},{"location":"api/gates-global-phase/","title":"Global Phase Gates API Reference","text":"<p>This page documents the global phase gates available in the <code>skq.gates.global_phase</code> module.</p>"},{"location":"api/gates-global-phase/#globalphase","title":"GlobalPhase","text":"<p>Global phase gates apply a phase shift to the entire quantum state.</p> <p>Matrix Representation:</p> \\[ \\text{GlobalPhase}(\\phi) = e^{i\\phi} \\cdot I \\] <p>Where \\(I\\) is the identity matrix of appropriate dimension.</p>"},{"location":"api/gates-global-phase/#skq.gates.global_phase.GlobalPhase","title":"<code>skq.gates.global_phase.GlobalPhase</code>","text":"<p>               Bases: <code>BaseGate</code></p> <p>Class representing a Global Phase :param phase: Global phase angle in radians</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>class GlobalPhase(BaseGate):\n    \"\"\"\n    Class representing a Global Phase\n    :param phase: Global phase angle in radians\n    \"\"\"\n\n    def __new__(cls, phase: float) -&gt; \"GlobalPhase\":\n        input_array = np.array([[np.exp(1j * phase)]], dtype=complex)\n        obj = super().__new__(cls, input_array)\n        assert obj.is_1x1(), \"Quscalar must be a 1x1 matrix\"\n        return obj\n\n    @property\n    def scalar(self) -&gt; complex:\n        \"\"\"Get the scalar value of the gate.\"\"\"\n        return self[0, 0]\n\n    @property\n    def phase(self) -&gt; float:\n        \"\"\"Get the global phase.\"\"\"\n        return np.angle(self.scalar)\n\n    def is_1x1(self) -&gt; bool:\n        \"\"\"Check if the gate is a 1x1 matrix.\"\"\"\n        return self.shape == (1, 1)\n\n    def inverse(self) -&gt; \"GlobalPhase\":\n        inverse_phase = -self.phase\n        return GlobalPhase(inverse_phase)\n\n    def combine(self, other: \"GlobalPhase\") -&gt; \"GlobalPhase\":\n        assert isinstance(other, GlobalPhase), \"Can only combine with another QuScalarGate.\"\n        combined_phase = self.phase + other.phase\n        return GlobalPhase(combined_phase)\n\n    def multiply(self, other: \"GlobalPhase\") -&gt; \"GlobalPhase\":\n        assert isinstance(other, GlobalPhase), \"Can only multiply with another QuScalarGate.\"\n        multiplied_phase = np.angle(self.scalar * other.scalar)\n        return GlobalPhase(multiplied_phase)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.GlobalPhaseGate:\n        \"\"\"Convert QuScalar to a Qiskit GlobalPhaseGate object.\"\"\"\n        return qiskit.circuit.library.GlobalPhaseGate(self.phase)\n\n    @staticmethod\n    def from_qiskit(qiskit_gate: qiskit.circuit.library.GlobalPhaseGate) -&gt; \"GlobalPhase\":\n        \"\"\"\n        Convert a Qiskit GlobalPhaseGate to a QuScalar object.\n        :param qiskit_gate: Qiskit GlobalPhaseGate object\n        :return: A QuScalar object\n        \"\"\"\n        if not isinstance(qiskit_gate, qiskit.circuit.library.GlobalPhaseGate):\n            raise ValueError(f\"Expected GlobalPhaseGate, got {type(qiskit_gate)}.\")\n        phase = qiskit_gate.params[0]\n        return GlobalPhase(phase)\n\n    def to_pennylane(self) -&gt; qml.GlobalPhase:\n        \"\"\"Convert QuScalar to a PennyLane GlobalPhase.\"\"\"\n        return qml.GlobalPhase(self.phase)\n\n    @staticmethod\n    def from_pennylane(pennylane_gate: qml.operation.Operation) -&gt; \"GlobalPhase\":\n        \"\"\"\n        Convert a PennyLane GlobalPhase to a QuScalar object.\n        :param pennylane_gate: PennyLane GlobalPhase object\n        :return: A QuScalar object\n        \"\"\"\n        if not isinstance(pennylane_gate, qml.GlobalPhase):\n            raise ValueError(f\"Expected GlobalPhase, got {type(pennylane_gate)}.\")\n        phase = pennylane_gate.parameters[0]\n        return GlobalPhase(phase)\n</code></pre>"},{"location":"api/gates-global-phase/#skq.gates.global_phase.GlobalPhase.phase","title":"<code>phase</code>  <code>property</code>","text":"<p>Get the global phase.</p>"},{"location":"api/gates-global-phase/#skq.gates.global_phase.GlobalPhase.scalar","title":"<code>scalar</code>  <code>property</code>","text":"<p>Get the scalar value of the gate.</p>"},{"location":"api/gates-global-phase/#skq.gates.global_phase.GlobalPhase.from_pennylane","title":"<code>from_pennylane(pennylane_gate)</code>  <code>staticmethod</code>","text":"<p>Convert a PennyLane GlobalPhase to a QuScalar object. :param pennylane_gate: PennyLane GlobalPhase object :return: A QuScalar object</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>@staticmethod\ndef from_pennylane(pennylane_gate: qml.operation.Operation) -&gt; \"GlobalPhase\":\n    \"\"\"\n    Convert a PennyLane GlobalPhase to a QuScalar object.\n    :param pennylane_gate: PennyLane GlobalPhase object\n    :return: A QuScalar object\n    \"\"\"\n    if not isinstance(pennylane_gate, qml.GlobalPhase):\n        raise ValueError(f\"Expected GlobalPhase, got {type(pennylane_gate)}.\")\n    phase = pennylane_gate.parameters[0]\n    return GlobalPhase(phase)\n</code></pre>"},{"location":"api/gates-global-phase/#skq.gates.global_phase.GlobalPhase.from_qiskit","title":"<code>from_qiskit(qiskit_gate)</code>  <code>staticmethod</code>","text":"<p>Convert a Qiskit GlobalPhaseGate to a QuScalar object. :param qiskit_gate: Qiskit GlobalPhaseGate object :return: A QuScalar object</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>@staticmethod\ndef from_qiskit(qiskit_gate: qiskit.circuit.library.GlobalPhaseGate) -&gt; \"GlobalPhase\":\n    \"\"\"\n    Convert a Qiskit GlobalPhaseGate to a QuScalar object.\n    :param qiskit_gate: Qiskit GlobalPhaseGate object\n    :return: A QuScalar object\n    \"\"\"\n    if not isinstance(qiskit_gate, qiskit.circuit.library.GlobalPhaseGate):\n        raise ValueError(f\"Expected GlobalPhaseGate, got {type(qiskit_gate)}.\")\n    phase = qiskit_gate.params[0]\n    return GlobalPhase(phase)\n</code></pre>"},{"location":"api/gates-global-phase/#skq.gates.global_phase.GlobalPhase.is_1x1","title":"<code>is_1x1()</code>","text":"<p>Check if the gate is a 1x1 matrix.</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>def is_1x1(self) -&gt; bool:\n    \"\"\"Check if the gate is a 1x1 matrix.\"\"\"\n    return self.shape == (1, 1)\n</code></pre>"},{"location":"api/gates-global-phase/#skq.gates.global_phase.GlobalPhase.to_pennylane","title":"<code>to_pennylane()</code>","text":"<p>Convert QuScalar to a PennyLane GlobalPhase.</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>def to_pennylane(self) -&gt; qml.GlobalPhase:\n    \"\"\"Convert QuScalar to a PennyLane GlobalPhase.\"\"\"\n    return qml.GlobalPhase(self.phase)\n</code></pre>"},{"location":"api/gates-global-phase/#skq.gates.global_phase.GlobalPhase.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert QuScalar to a Qiskit GlobalPhaseGate object.</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>def to_qiskit(self) -&gt; qiskit.circuit.library.GlobalPhaseGate:\n    \"\"\"Convert QuScalar to a Qiskit GlobalPhaseGate object.\"\"\"\n    return qiskit.circuit.library.GlobalPhaseGate(self.phase)\n</code></pre>"},{"location":"api/gates-global-phase/#predefined-phase-gates","title":"Predefined Phase Gates","text":"<p>SKQ provides several predefined global phase gates:</p>"},{"location":"api/gates-global-phase/#identity-no-phase-shift","title":"Identity (No Phase Shift)","text":"<p>Matrix Representation:</p> \\[ \\text{Identity} = e^{i \\cdot 0} \\cdot I = I \\]"},{"location":"api/gates-global-phase/#skq.gates.global_phase.Identity","title":"<code>skq.gates.global_phase.Identity</code>","text":"<p>               Bases: <code>GlobalPhase</code></p> <p>No phase shift.</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>class Identity(GlobalPhase):\n    \"\"\"No phase shift.\"\"\"\n\n    def __new__(cls) -&gt; \"Identity\":\n        return super().__new__(cls, 0.0)\n</code></pre>"},{"location":"api/gates-global-phase/#quarterphase-2","title":"QuarterPhase (\u03c0/2)","text":"<p>Matrix Representation:</p> \\[ \\text{QuarterPhase} = e^{i\\pi/2} \\cdot I = i \\cdot I \\]"},{"location":"api/gates-global-phase/#skq.gates.global_phase.QuarterPhase","title":"<code>skq.gates.global_phase.QuarterPhase</code>","text":"<p>               Bases: <code>GlobalPhase</code></p> <p>Quarter phase shift (\u03c0/2)</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>class QuarterPhase(GlobalPhase):\n    \"\"\"Quarter phase shift (\u03c0/2)\"\"\"\n\n    def __new__(cls) -&gt; \"QuarterPhase\":\n        return super().__new__(cls, np.pi / 2)\n</code></pre>"},{"location":"api/gates-global-phase/#halfphase","title":"HalfPhase (\u03c0)","text":"<p>Matrix Representation:</p> \\[ \\text{HalfPhase} = e^{i\\pi} \\cdot I = -1 \\cdot I \\]"},{"location":"api/gates-global-phase/#skq.gates.global_phase.HalfPhase","title":"<code>skq.gates.global_phase.HalfPhase</code>","text":"<p>               Bases: <code>GlobalPhase</code></p> <p>Half phase shift (\u03c0)</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>class HalfPhase(GlobalPhase):\n    \"\"\"Half phase shift (\u03c0)\"\"\"\n\n    def __new__(cls) -&gt; \"HalfPhase\":\n        return super().__new__(cls, np.pi)\n</code></pre>"},{"location":"api/gates-global-phase/#threequarterphase-32","title":"ThreeQuarterPhase (3\u03c0/2)","text":"<p>Matrix Representation:</p> \\[ \\text{ThreeQuarterPhase} = e^{i3\\pi/2} \\cdot I = -i \\cdot I \\]"},{"location":"api/gates-global-phase/#skq.gates.global_phase.ThreeQuarterPhase","title":"<code>skq.gates.global_phase.ThreeQuarterPhase</code>","text":"<p>               Bases: <code>GlobalPhase</code></p> <p>Three quarters phase shift (3\u03c0/2)</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>class ThreeQuarterPhase(GlobalPhase):\n    \"\"\"Three quarters phase shift (3\u03c0/2)\"\"\"\n\n    def __new__(cls) -&gt; \"ThreeQuarterPhase\":\n        return super().__new__(cls, 3 * np.pi / 2)\n</code></pre>"},{"location":"api/gates-global-phase/#fullphase-2","title":"FullPhase (2\u03c0)","text":"<p>Matrix Representation:</p> \\[ \\text{FullPhase} = e^{i2\\pi} \\cdot I = I \\]"},{"location":"api/gates-global-phase/#skq.gates.global_phase.FullPhase","title":"<code>skq.gates.global_phase.FullPhase</code>","text":"<p>               Bases: <code>GlobalPhase</code></p> <p>Full phase shift (2\u03c0)</p> Source code in <code>src/skq/gates/global_phase.py</code> <pre><code>class FullPhase(GlobalPhase):\n    \"\"\"Full phase shift (2\u03c0)\"\"\"\n\n    def __new__(cls) -&gt; \"FullPhase\":\n        return super().__new__(cls, 2 * np.pi)\n</code></pre>"},{"location":"api/gates-qubit/","title":"Qubit Gates API Reference","text":"<p>This page documents the qubit gates available in the <code>skq.gates.qubit</code> module.</p>"},{"location":"api/gates-qubit/#qubit-gate-base-class","title":"Qubit Gate Base Class","text":"<p>The <code>QubitGate</code> class serves as the foundation for all qubit-based quantum gates in SKQ.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate","title":"<code>skq.gates.qubit.base.QubitGate</code>","text":"<p>               Bases: <code>BaseGate</code></p> <p>Base class for Qubit gates. A quantum system with 2 basis states (|0&gt;, |1&gt;). Models spin-1/2 particles like electrons.</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>class QubitGate(BaseGate):\n    \"\"\"\n    Base class for Qubit gates.\n    A quantum system with 2 basis states (|0&gt;, |1&gt;).\n    Models spin-1/2 particles like electrons.\n    \"\"\"\n\n    def __new__(cls, input_array):\n        obj = super().__new__(cls, input_array)\n        assert obj.is_at_least_nxn(n=2), \"Gate must be at least a 2x2 matrix.\"\n        assert obj.is_power_of_n_shape(n=2), \"Gate shape must be a power of 2.\"\n        return obj\n\n    @property\n    def num_qubits(self) -&gt; int:\n        \"\"\"Return the number of qubits involved in the gate.\"\"\"\n        return int(np.log2(self.shape[0]))\n\n    def is_multi_qubit(self) -&gt; bool:\n        \"\"\"Check if the gate involves multiple qubits.\"\"\"\n        return self.num_qubits &gt; 1\n\n    def is_pauli(self) -&gt; bool:\n        \"\"\"Check if the gate is a Pauli gate.\"\"\"\n        # I, X, Y, Z Pauli matrices\n        if self.num_qubits == 1:\n            return any(np.allclose(self, pauli) for pauli in SINGLE_QUBIT_PAULI_MATRICES)\n        # Combinations of single-qubit Pauli matrices\n        elif self.num_qubits == 2:\n            return any(np.allclose(self, pauli) for pauli in TWO_QUBIT_PAULI_MATRICES)\n        else:\n            return NotImplementedError(\"Pauli check not supported for gates with more than 2 qubits\")\n\n    def is_clifford(self) -&gt; bool:\n        \"\"\"Check if the gate is a Clifford gate.\"\"\"\n        # X, Y, Z, H and S\n        if self.num_qubits == 1:\n            return any(np.allclose(self, clifford) for clifford in SINGLE_QUBIT_CLIFFORD_MATRICES)\n        # Combinations of single-qubit Clifford gates + CNOT and SWAP\n        elif self.num_qubits == 2:\n            return any(np.allclose(self, clifford) for clifford in TWO_QUBIT_CLIFFORD_MATRICES)\n        else:\n            return NotImplementedError(\"Clifford check not supported for gates with more than 2 qubits\")\n\n    def sqrt(self) -&gt; \"CustomQubitGate\":\n        \"\"\"Compute the square root of the gate.\"\"\"\n        sqrt_matrix = sp.linalg.sqrtm(self)\n        return CustomQubitGate(sqrt_matrix)\n\n    def kron(self, other: \"QubitGate\") -&gt; \"CustomQubitGate\":\n        \"\"\"Compute the Kronecker product of two gates.\"\"\"\n        kron_matrix = np.kron(self, other)\n        return CustomQubitGate(kron_matrix)\n\n    def convert_endianness(self) -&gt; \"QubitGate\":\n        \"\"\"Convert a gate matrix from big-endian to little-endian and vice versa.\"\"\"\n        if self.num_qubits == 1:\n            return self\n        permutation = np.arange(2**self.num_qubits).reshape([2] * self.num_qubits).transpose().flatten()\n        return self[permutation][:, permutation]\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n        \"\"\"\n        Convert gate to a Qiskit Gate object.\n        Qiskit using little endian convention, so we permute the order of the qubits.\n        :return: Qiskit UnitaryGate object\n        \"\"\"\n        gate_name = self.__class__.__name__\n        print(f\"No to_qiskit defined for '{gate_name}'. Initializing as UnitaryGate.\")\n        return qiskit.circuit.library.UnitaryGate(self.convert_endianness(), label=gate_name)\n\n    @staticmethod\n    def from_qiskit(gate: qiskit.circuit.gate.Gate) -&gt; \"CustomQubitGate\":\n        \"\"\"\n        Convert a Qiskit Gate to skq CustomGate.\n        Qiskit using little endian convention, so we permute the order of the qubits.\n        :param gate: Qiskit Gate object\n        \"\"\"\n        assert isinstance(gate, qiskit.circuit.gate.Gate), \"Input must be a Qiskit Gate object\"\n        return CustomQubitGate(gate.to_matrix()).convert_endianness()\n\n    def to_pennylane(self, wires: list[int] | int = None) -&gt; qml.QubitUnitary:\n        \"\"\"\n        Convert gate to a PennyLane QubitUnitary.\n        PennyLane use the big endian convention, so no need to reverse the order of the qubits.\n        :param wires: List of wires the gate acts on\n        :return: PennyLane QubitUnitary object\n        \"\"\"\n        gate_name = self.__class__.__name__\n        print(f\"No to_pennylane defined for '{gate_name}'. Initializing as QubitUnitary.\")\n        wires = wires if wires is not None else list(range(self.num_qubits))\n        return qml.QubitUnitary(self, wires=wires)\n\n    @staticmethod\n    def from_pennylane(gate: qml.operation.Operation) -&gt; \"CustomQubitGate\":\n        \"\"\"\n        Convert a PennyLane Operation to skqq CustomGate.\n        PennyLane use the big endian convention, so no need to reverse the order of the qubits.\n        :param gate: PennyLane Operation object\n        \"\"\"\n        assert isinstance(gate, qml.operation.Operation), \"Input must be a PennyLane Operation object\"\n        return CustomQubitGate(gate.matrix())\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        \"\"\"\n        Convert gate to a OpenQASM string.\n        More information on OpenQASM (2.0): https://arxiv.org/pdf/1707.03429\n        OpenQASM specification: https://openqasm.com/intro.html\n        Gates should be part of the standard library.\n        OpenQASM 2.0 -&gt; qelib1.inc\n        OpenQASM 3 -&gt; stdgates.inc\n        :param qubits: List of qubit indices the gate acts on\n        :return: OpenQASM string representation of the gate\n        String representation should define gate, qubits it acts on and ;.\n        Example for Hadamard in 1st qubit -&gt; \"h q[0];\"\n        \"\"\"\n        raise NotImplementedError(\"Conversion to OpenQASM is not implemented.\")\n\n    @staticmethod\n    def from_qasm(qasm_string: str) -&gt; \"QubitGate\":\n        \"\"\"Convert a OpenQASM string to scikit-q gate.\"\"\"\n        raise NotImplementedError(\"Conversion from OpenQASM is not implemented.\")\n\n    def draw(self, **kwargs):\n        \"\"\"Draw the gate using a Qiskit QuantumCircuit.\"\"\"\n        qc = QuantumCircuit(self.num_qubits)\n        qc.append(self.to_qiskit(), range(self.num_qubits))\n        return qc.draw(**kwargs)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.num_qubits","title":"<code>num_qubits</code>  <code>property</code>","text":"<p>Return the number of qubits involved in the gate.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.convert_endianness","title":"<code>convert_endianness()</code>","text":"<p>Convert a gate matrix from big-endian to little-endian and vice versa.</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def convert_endianness(self) -&gt; \"QubitGate\":\n    \"\"\"Convert a gate matrix from big-endian to little-endian and vice versa.\"\"\"\n    if self.num_qubits == 1:\n        return self\n    permutation = np.arange(2**self.num_qubits).reshape([2] * self.num_qubits).transpose().flatten()\n    return self[permutation][:, permutation]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.draw","title":"<code>draw(**kwargs)</code>","text":"<p>Draw the gate using a Qiskit QuantumCircuit.</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def draw(self, **kwargs):\n    \"\"\"Draw the gate using a Qiskit QuantumCircuit.\"\"\"\n    qc = QuantumCircuit(self.num_qubits)\n    qc.append(self.to_qiskit(), range(self.num_qubits))\n    return qc.draw(**kwargs)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.from_pennylane","title":"<code>from_pennylane(gate)</code>  <code>staticmethod</code>","text":"<p>Convert a PennyLane Operation to skqq CustomGate. PennyLane use the big endian convention, so no need to reverse the order of the qubits. :param gate: PennyLane Operation object</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>@staticmethod\ndef from_pennylane(gate: qml.operation.Operation) -&gt; \"CustomQubitGate\":\n    \"\"\"\n    Convert a PennyLane Operation to skqq CustomGate.\n    PennyLane use the big endian convention, so no need to reverse the order of the qubits.\n    :param gate: PennyLane Operation object\n    \"\"\"\n    assert isinstance(gate, qml.operation.Operation), \"Input must be a PennyLane Operation object\"\n    return CustomQubitGate(gate.matrix())\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.from_qasm","title":"<code>from_qasm(qasm_string)</code>  <code>staticmethod</code>","text":"<p>Convert a OpenQASM string to scikit-q gate.</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>@staticmethod\ndef from_qasm(qasm_string: str) -&gt; \"QubitGate\":\n    \"\"\"Convert a OpenQASM string to scikit-q gate.\"\"\"\n    raise NotImplementedError(\"Conversion from OpenQASM is not implemented.\")\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.from_qiskit","title":"<code>from_qiskit(gate)</code>  <code>staticmethod</code>","text":"<p>Convert a Qiskit Gate to skq CustomGate. Qiskit using little endian convention, so we permute the order of the qubits. :param gate: Qiskit Gate object</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>@staticmethod\ndef from_qiskit(gate: qiskit.circuit.gate.Gate) -&gt; \"CustomQubitGate\":\n    \"\"\"\n    Convert a Qiskit Gate to skq CustomGate.\n    Qiskit using little endian convention, so we permute the order of the qubits.\n    :param gate: Qiskit Gate object\n    \"\"\"\n    assert isinstance(gate, qiskit.circuit.gate.Gate), \"Input must be a Qiskit Gate object\"\n    return CustomQubitGate(gate.to_matrix()).convert_endianness()\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.is_clifford","title":"<code>is_clifford()</code>","text":"<p>Check if the gate is a Clifford gate.</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def is_clifford(self) -&gt; bool:\n    \"\"\"Check if the gate is a Clifford gate.\"\"\"\n    # X, Y, Z, H and S\n    if self.num_qubits == 1:\n        return any(np.allclose(self, clifford) for clifford in SINGLE_QUBIT_CLIFFORD_MATRICES)\n    # Combinations of single-qubit Clifford gates + CNOT and SWAP\n    elif self.num_qubits == 2:\n        return any(np.allclose(self, clifford) for clifford in TWO_QUBIT_CLIFFORD_MATRICES)\n    else:\n        return NotImplementedError(\"Clifford check not supported for gates with more than 2 qubits\")\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.is_multi_qubit","title":"<code>is_multi_qubit()</code>","text":"<p>Check if the gate involves multiple qubits.</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def is_multi_qubit(self) -&gt; bool:\n    \"\"\"Check if the gate involves multiple qubits.\"\"\"\n    return self.num_qubits &gt; 1\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.is_pauli","title":"<code>is_pauli()</code>","text":"<p>Check if the gate is a Pauli gate.</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def is_pauli(self) -&gt; bool:\n    \"\"\"Check if the gate is a Pauli gate.\"\"\"\n    # I, X, Y, Z Pauli matrices\n    if self.num_qubits == 1:\n        return any(np.allclose(self, pauli) for pauli in SINGLE_QUBIT_PAULI_MATRICES)\n    # Combinations of single-qubit Pauli matrices\n    elif self.num_qubits == 2:\n        return any(np.allclose(self, pauli) for pauli in TWO_QUBIT_PAULI_MATRICES)\n    else:\n        return NotImplementedError(\"Pauli check not supported for gates with more than 2 qubits\")\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.kron","title":"<code>kron(other)</code>","text":"<p>Compute the Kronecker product of two gates.</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def kron(self, other: \"QubitGate\") -&gt; \"CustomQubitGate\":\n    \"\"\"Compute the Kronecker product of two gates.\"\"\"\n    kron_matrix = np.kron(self, other)\n    return CustomQubitGate(kron_matrix)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.sqrt","title":"<code>sqrt()</code>","text":"<p>Compute the square root of the gate.</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def sqrt(self) -&gt; \"CustomQubitGate\":\n    \"\"\"Compute the square root of the gate.\"\"\"\n    sqrt_matrix = sp.linalg.sqrtm(self)\n    return CustomQubitGate(sqrt_matrix)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.to_pennylane","title":"<code>to_pennylane(wires=None)</code>","text":"<p>Convert gate to a PennyLane QubitUnitary. PennyLane use the big endian convention, so no need to reverse the order of the qubits. :param wires: List of wires the gate acts on :return: PennyLane QubitUnitary object</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def to_pennylane(self, wires: list[int] | int = None) -&gt; qml.QubitUnitary:\n    \"\"\"\n    Convert gate to a PennyLane QubitUnitary.\n    PennyLane use the big endian convention, so no need to reverse the order of the qubits.\n    :param wires: List of wires the gate acts on\n    :return: PennyLane QubitUnitary object\n    \"\"\"\n    gate_name = self.__class__.__name__\n    print(f\"No to_pennylane defined for '{gate_name}'. Initializing as QubitUnitary.\")\n    wires = wires if wires is not None else list(range(self.num_qubits))\n    return qml.QubitUnitary(self, wires=wires)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.to_qasm","title":"<code>to_qasm(qubits)</code>","text":"<p>Convert gate to a OpenQASM string. More information on OpenQASM (2.0): https://arxiv.org/pdf/1707.03429 OpenQASM specification: https://openqasm.com/intro.html Gates should be part of the standard library. OpenQASM 2.0 -&gt; qelib1.inc OpenQASM 3 -&gt; stdgates.inc :param qubits: List of qubit indices the gate acts on :return: OpenQASM string representation of the gate String representation should define gate, qubits it acts on and ;. Example for Hadamard in 1st qubit -&gt; \"h q[0];\"</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def to_qasm(self, qubits: list[int]) -&gt; str:\n    \"\"\"\n    Convert gate to a OpenQASM string.\n    More information on OpenQASM (2.0): https://arxiv.org/pdf/1707.03429\n    OpenQASM specification: https://openqasm.com/intro.html\n    Gates should be part of the standard library.\n    OpenQASM 2.0 -&gt; qelib1.inc\n    OpenQASM 3 -&gt; stdgates.inc\n    :param qubits: List of qubit indices the gate acts on\n    :return: OpenQASM string representation of the gate\n    String representation should define gate, qubits it acts on and ;.\n    Example for Hadamard in 1st qubit -&gt; \"h q[0];\"\n    \"\"\"\n    raise NotImplementedError(\"Conversion to OpenQASM is not implemented.\")\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.base.QubitGate.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert gate to a Qiskit Gate object. Qiskit using little endian convention, so we permute the order of the qubits. :return: Qiskit UnitaryGate object</p> Source code in <code>src/skq/gates/qubit/base.py</code> <pre><code>def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n    \"\"\"\n    Convert gate to a Qiskit Gate object.\n    Qiskit using little endian convention, so we permute the order of the qubits.\n    :return: Qiskit UnitaryGate object\n    \"\"\"\n    gate_name = self.__class__.__name__\n    print(f\"No to_qiskit defined for '{gate_name}'. Initializing as UnitaryGate.\")\n    return qiskit.circuit.library.UnitaryGate(self.convert_endianness(), label=gate_name)\n</code></pre>"},{"location":"api/gates-qubit/#single-qubit-gates","title":"Single-Qubit Gates","text":""},{"location":"api/gates-qubit/#identity-gate-i","title":"Identity Gate (I)","text":"<p>The Identity gate leaves the qubit state unchanged.</p> <p>Matrix Representation:</p> <pre><code>I = [1 0]\n    [0 1]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.I","title":"<code>skq.gates.qubit.single.I</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Identity gate: [[1, 0][0, 1]]</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class I(QubitGate):\n    \"\"\"\n    Identity gate:\n    [[1, 0]\n    [0, 1]]\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, np.eye(2))\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.IGate:\n        return qiskit.circuit.library.IGate()\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.I:\n        return qml.I(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"id q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#pauli-x-gate-not","title":"Pauli-X Gate (NOT)","text":"<p>The Pauli-X gate is the quantum equivalent of the classical NOT gate. It flips the state of the qubit.</p> <p>Matrix Representation:</p> <pre><code>X = [0 1]\n    [1 0]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.X","title":"<code>skq.gates.qubit.single.X</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Pauli X (NOT) Gate.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class X(QubitGate):\n    \"\"\"Pauli X (NOT) Gate.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[0, 1], [1, 0]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.XGate:\n        return qiskit.circuit.library.XGate()\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.X:\n        return qml.X(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"x q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#pauli-y-gate","title":"Pauli-Y Gate","text":"<p>The Pauli-Y gate rotates the qubit state around the Y-axis of the Bloch sphere.</p> <p>Matrix Representation:</p> <pre><code>Y = [0  -i]\n    [i   0]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.Y","title":"<code>skq.gates.qubit.single.Y</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Pauli Y gate.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class Y(QubitGate):\n    \"\"\"Pauli Y gate.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[0, -1j], [1j, 0]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.YGate:\n        return qiskit.circuit.library.YGate()\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.Y:\n        return qml.Y(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"y q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#pauli-z-gate","title":"Pauli-Z Gate","text":"<p>The Pauli-Z gate rotates the qubit state around the Z-axis of the Bloch sphere.</p> <p>Matrix Representation:</p> <pre><code>Z = [1  0]\n    [0 -1]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.Z","title":"<code>skq.gates.qubit.single.Z</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Pauli Z gate. Special case of a phase shift gate with phi = pi.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class Z(QubitGate):\n    \"\"\"Pauli Z gate.\n    Special case of a phase shift gate with phi = pi.\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0], [0, -1]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.ZGate:\n        return qiskit.circuit.library.ZGate()\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.Z:\n        return qml.Z(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"z q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#hadamard-gate-h","title":"Hadamard Gate (H)","text":"<p>The Hadamard gate creates a superposition of the |0\u27e9 and |1\u27e9 states.</p> <p>Matrix Representation:</p> <pre><code>H = 1/\u221a2 * [1  1]\n           [1 -1]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.H","title":"<code>skq.gates.qubit.single.H</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Hadamard gate. Used to create superposition. |0&gt; -&gt; (|0&gt; + |1&gt;) / sqrt(2) |1&gt; -&gt; (|0&gt; - |1&gt;) / sqrt(2)</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class H(QubitGate):\n    \"\"\"\n    Hadamard gate. Used to create superposition.\n    |0&gt; -&gt; (|0&gt; + |1&gt;) / sqrt(2)\n    |1&gt; -&gt; (|0&gt; - |1&gt;) / sqrt(2)\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 1], [1, -1]] / np.sqrt(2))\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.HGate:\n        return qiskit.circuit.library.HGate()\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.Hadamard:\n        return qml.Hadamard(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"h q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#phase-gate","title":"Phase Gate","text":"<p>The general Phase gate applies a phase shift to the |1\u27e9 state.</p> <p>Matrix Representation:</p> <pre><code>Phase(\u03c6) = [1      0    ]\n           [0  e^(i\u03c6)]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.Phase","title":"<code>skq.gates.qubit.single.Phase</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>General phase shift gate. Special cases of phase gates: - S gate: phi = pi / 2 - T gate: phi = pi / 4 - Z gate: phi = pi</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class Phase(QubitGate):\n    \"\"\"General phase shift gate.\n    Special cases of phase gates:\n    - S gate: phi = pi / 2\n    - T gate: phi = pi / 4\n    - Z gate: phi = pi\n    \"\"\"\n\n    def __new__(cls, phi):\n        obj = super().__new__(cls, [[1, 0], [0, np.exp(1j * phi)]])\n        obj.phi = phi\n        return obj\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.PhaseGate:\n        return qiskit.circuit.library.PhaseGate(self.phi)\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.PhaseShift:\n        return qml.PhaseShift(phi=self.phi, wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"U(0, 0, {self.phi}) q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#s-gate-2-phase","title":"S Gate (\u03c0/2 Phase)","text":"<p>The S gate is a special case of the Phase gate with \u03c6 = \u03c0/2.</p> <p>Matrix Representation:</p> <pre><code>S = [1  0]\n    [0  i]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.S","title":"<code>skq.gates.qubit.single.S</code>","text":"<p>               Bases: <code>Phase</code></p> <p>S gate: phase shift gate with phi = pi / 2.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class S(Phase):\n    \"\"\"S gate: phase shift gate with phi = pi / 2.\"\"\"\n\n    def __new__(cls):\n        phi = np.pi / 2\n        return super().__new__(cls, phi=phi)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.SGate:\n        return qiskit.circuit.library.SGate()\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.S:\n        return qml.S(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"s q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#t-gate-4-phase","title":"T Gate (\u03c0/4 Phase)","text":"<p>The T gate is a special case of the Phase gate with \u03c6 = \u03c0/4.</p> <p>Matrix Representation:</p> <pre><code>T = [1       0    ]\n    [0  e^(i\u03c0/4)]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.T","title":"<code>skq.gates.qubit.single.T</code>","text":"<p>               Bases: <code>Phase</code></p> <p>T gate: phase shift gate with phi = pi / 4.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class T(Phase):\n    \"\"\"T gate: phase shift gate with phi = pi / 4.\"\"\"\n\n    def __new__(cls):\n        phi = np.pi / 4\n        return super().__new__(cls, phi=phi)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.TGate:\n        return qiskit.circuit.library.TGate()\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.PhaseShift:\n        return qml.T(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"t q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#rx-gate-x-rotation","title":"RX Gate (X-Rotation)","text":"<p>The RX gate rotates the qubit state around the X-axis of the Bloch sphere.</p> <p>Matrix Representation:</p> <pre><code>RX(\u03c6) = [    cos(\u03c6/2)  -i\u00b7sin(\u03c6/2)]\n        [-i\u00b7sin(\u03c6/2)      cos(\u03c6/2)]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.RX","title":"<code>skq.gates.qubit.single.RX</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Generalized X rotation gate.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class RX(QubitGate):\n    \"\"\"Generalized X rotation gate.\"\"\"\n\n    def __new__(cls, phi):\n        obj = super().__new__(cls, [[np.cos(phi / 2), -1j * np.sin(phi / 2)], [-1j * np.sin(phi / 2), np.cos(phi / 2)]])\n        obj.phi = phi\n        return obj\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.RXGate:\n        return qiskit.circuit.library.RXGate(self.phi)\n\n    def to_pennylane(self, wires: list[int] | int = None) -&gt; qml.RX:\n        return qml.RX(phi=self.phi, wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"rx({self.phi}) q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#ry-gate-y-rotation","title":"RY Gate (Y-Rotation)","text":"<p>The RY gate rotates the qubit state around the Y-axis of the Bloch sphere.</p> <p>Matrix Representation:</p> <pre><code>RY(\u03c6) = [cos(\u03c6/2)  -sin(\u03c6/2)]\n        [sin(\u03c6/2)   cos(\u03c6/2)]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.RY","title":"<code>skq.gates.qubit.single.RY</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Generalized Y rotation gate.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class RY(QubitGate):\n    \"\"\"Generalized Y rotation gate.\"\"\"\n\n    def __new__(cls, phi):\n        obj = super().__new__(cls, [[np.cos(phi / 2), -np.sin(phi / 2)], [np.sin(phi / 2), np.cos(phi / 2)]])\n        obj.phi = phi\n        return obj\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.RYGate:\n        return qiskit.circuit.library.RYGate(self.phi)\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.RY:\n        return qml.RY(phi=self.phi, wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"ry({self.phi}) q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#rz-gate-z-rotation","title":"RZ Gate (Z-Rotation)","text":"<p>The RZ gate rotates the qubit state around the Z-axis of the Bloch sphere.</p> <p>Matrix Representation:</p> <pre><code>RZ(\u03c6) = [e^(-i\u03c6/2)       0    ]\n        [    0      e^(i\u03c6/2)]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.RZ","title":"<code>skq.gates.qubit.single.RZ</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Generalized Z rotation gate.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class RZ(QubitGate):\n    \"\"\"Generalized Z rotation gate.\"\"\"\n\n    def __new__(cls, phi):\n        obj = super().__new__(cls, [[np.exp(-1j * phi / 2), 0], [0, np.exp(1j * phi / 2)]])\n        obj.phi = phi\n        return obj\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.RZGate:\n        return qiskit.circuit.library.RZGate(self.phi)\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.RZ:\n        return qml.RZ(phi=self.phi, wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"rz({self.phi}) q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#r-gate-general-rotation","title":"R Gate (General Rotation)","text":"<p>The R gate implements a general rotation by composing RZ, RY, and RZ rotations.</p> <p>Matrix Representation:</p> <pre><code>R(\u03b8,\u03c6,\u03bb) = RZ(\u03bb) \u00b7 RY(\u03c6) \u00b7 RZ(\u03b8)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.R","title":"<code>skq.gates.qubit.single.R</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Generalized 3-axis rotation gate.</p> <p>Implements a rotation by composing: RZ(gamma) \u00b7 RY(beta) \u00b7 RZ(alpha)</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class R(QubitGate):\n    \"\"\"Generalized 3-axis rotation gate.\n\n    Implements a rotation by composing: RZ(gamma) \u00b7 RY(beta) \u00b7 RZ(alpha)\n    \"\"\"\n\n    def __new__(cls, theta, phi, lam):\n        obj = super().__new__(cls, RZ(lam) @ RY(phi) @ RZ(theta))\n        obj.theta = theta\n        obj.phi = phi\n        obj.lam = lam\n        return obj\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.UGate:\n        return qiskit.circuit.library.UGate(self.theta, self.phi, self.lam)\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.Rot:\n        return qml.Rot(phi=self.theta, theta=self.phi, omega=self.lam, wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"U({self.theta}, {self.phi}, {self.lam}) q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#u3-gate-universal-rotation","title":"U3 Gate (Universal Rotation)","text":"<p>The U3 gate is a universal single-qubit gate that can represent any single-qubit operation.</p> <p>Matrix Representation:</p> <pre><code>U3(\u03b8,\u03c6,\u03b4) = RZ(\u03b4) \u00b7 RY(\u03c6) \u00b7 RX(\u03b8)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.U3","title":"<code>skq.gates.qubit.single.U3</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Rotation around 3-axes. Single qubit gate. :param theta: Rotation angle around X-axis :param phi: Rotation angle around Y-axis :param delta: Rotation angle around Z-axis</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class U3(QubitGate):\n    \"\"\"\n    Rotation around 3-axes. Single qubit gate.\n    :param theta: Rotation angle around X-axis\n    :param phi: Rotation angle around Y-axis\n    :param delta: Rotation angle around Z-axis\n    \"\"\"\n\n    def __new__(cls, theta: float, phi: float, delta: float):\n        # Rotation matrices\n        Rx = RX(theta)\n        Ry = RY(phi)\n        Rz = RZ(delta)\n        combined_matrix = Rz @ Ry @ Rx\n\n        obj = super().__new__(cls, combined_matrix)\n        obj.theta = theta\n        obj.phi = phi\n        obj.delta = delta\n        return obj\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.U3Gate:\n        return qiskit.circuit.library.U3Gate(self.theta, self.phi, self.delta)\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.U3:\n        return qml.U3(theta=self.theta, phi=self.phi, delta=self.delta, wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return f\"rx({self.theta}) q[{qubits[0]}];\\nry({self.phi}) q[{qubits[0]}];\\nrz({self.delta}) q[{qubits[0]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#measure-gate","title":"Measure Gate","text":"<p>The Measure gate performs a measurement on the qubit.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.Measure","title":"<code>skq.gates.qubit.single.Measure</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Measurement gate that returns probabilities of measuring |0\u27e9 and |1\u27e9.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>class Measure(QubitGate):\n    \"\"\"Measurement gate that returns probabilities of measuring |0\u27e9 and |1\u27e9.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, np.eye(2))\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.Measure:\n        return qiskit.circuit.library.Measure()\n\n    def to_pennylane(self, wires: list[int] | int) -&gt; qml.measure:\n        return qml.measure(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        return \"\\n\".join(f\"measure q[{q}] -&gt; c[{q}];\" for q in range(len(qubits)))\n\n    def __call__(self, state: np.ndarray) -&gt; np.ndarray:\n        \"\"\"\n        Apply measurement to a quantum state and return probabilities.\n        :param state: Quantum state vector.\n        :return: Array of probabilities for all possible measurement outcomes.\n        \"\"\"\n        return np.abs(state) ** 2\n\n    def encodes(self, x: np.ndarray) -&gt; np.ndarray:\n        return self.__call__(x)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.single.Measure.__call__","title":"<code>__call__(state)</code>","text":"<p>Apply measurement to a quantum state and return probabilities. :param state: Quantum state vector. :return: Array of probabilities for all possible measurement outcomes.</p> Source code in <code>src/skq/gates/qubit/single.py</code> <pre><code>def __call__(self, state: np.ndarray) -&gt; np.ndarray:\n    \"\"\"\n    Apply measurement to a quantum state and return probabilities.\n    :param state: Quantum state vector.\n    :return: Array of probabilities for all possible measurement outcomes.\n    \"\"\"\n    return np.abs(state) ** 2\n</code></pre>"},{"location":"api/gates-qubit/#multi-qubit-gates","title":"Multi-Qubit Gates","text":""},{"location":"api/gates-qubit/#cnot-cx-gate","title":"CNOT (CX) Gate","text":"<p>The CNOT (Controlled-NOT) gate flips the target qubit if the control qubit is |1\u27e9.</p> <p>Matrix Representation:</p> <pre><code>CX = [1 0 0 0]\n     [0 1 0 0]\n     [0 0 0 1]\n     [0 0 1 0]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CX","title":"<code>skq.gates.qubit.multi.CX</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Controlled-X (CNOT) gate. Used to entangle two qubits. If the control qubit is |1&gt;, the target qubit is flipped.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CX(QubitGate):\n    \"\"\"\n    Controlled-X (CNOT) gate.\n    Used to entangle two qubits.\n    If the control qubit is |1&gt;, the target qubit is flipped.\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CXGate:\n        return qiskit.circuit.library.CXGate()\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.CNOT:\n        assert len(wires) == 2, \"PennyLane CX gate requires 2 wires.\"\n        return qml.CNOT(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 2, \"OpenQASM CX gate requires 2 qubits.\"\n        return f\"cx q[{qubits[0]}], q[{qubits[1]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#controlled-y-cy-gate","title":"Controlled-Y (CY) Gate","text":"<p>The CY gate applies a Y gate to the target qubit if the control qubit is |1\u27e9.</p> <p>Matrix Representation:</p> <pre><code>CY = [1 0  0   0]\n     [0 1  0   0]\n     [0 0  0  -i]\n     [0 0  i   0]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CY","title":"<code>skq.gates.qubit.multi.CY</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Controlled-Y gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CY(QubitGate):\n    \"\"\"Controlled-Y gate.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, -1j], [0, 0, 1j, 0]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CYGate:\n        return qiskit.circuit.library.CYGate()\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.CY:\n        assert len(wires) == 2, \"PennyLane CY gate requires 2 wires.\"\n        return qml.CY(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 2, \"OpenQASM CY gate requires 2 qubits.\"\n        return f\"cy q[{qubits[0]}], q[{qubits[1]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#controlled-z-cz-gate","title":"Controlled-Z (CZ) Gate","text":"<p>The CZ gate applies a Z gate to the target qubit if the control qubit is |1\u27e9.</p> <p>Matrix Representation:</p> <pre><code>CZ = [1 0 0  0]\n     [0 1 0  0]\n     [0 0 1  0]\n     [0 0 0 -1]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CZ","title":"<code>skq.gates.qubit.multi.CZ</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Controlled-Z gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CZ(QubitGate):\n    \"\"\"Controlled-Z gate.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, -1]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CZGate:\n        return qiskit.circuit.library.CZGate()\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.CZ:\n        assert len(wires) == 2, \"PennyLane CZ gate requires 2 wires.\"\n        return qml.CZ(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 2, \"OpenQASM CZ gate requires 2 qubits.\"\n        return f\"cz q[{qubits[0]}], q[{qubits[1]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#controlled-h-ch-gate","title":"Controlled-H (CH) Gate","text":"<p>The CH gate applies a Hadamard gate to the target qubit if the control qubit is |1\u27e9.</p> <p>Matrix Representation:</p> <pre><code>CH = [1 0                0                 0              ]\n     [0 1                0                 0              ]\n     [0 0  1/\u221a2          1/\u221a2             ]\n     [0 0  1/\u221a2         -1/\u221a2             ]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CH","title":"<code>skq.gates.qubit.multi.CH</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Controlled-Hadamard gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CH(QubitGate):\n    \"\"\"Controlled-Hadamard gate.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1 / np.sqrt(2), 1 / np.sqrt(2)], [0, 0, 1 / np.sqrt(2), -1 / np.sqrt(2)]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CHGate:\n        return qiskit.circuit.library.CHGate()\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.CH:\n        assert len(wires) == 2, \"PennyLane CH gate requires 2 wires.\"\n        return qml.CH(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 2, \"OpenQASM CH gate requires 2 qubits.\"\n        return f\"ch q[{qubits[0]}], q[{qubits[1]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#controlled-phase-cphase-gate","title":"Controlled-Phase (CPhase) Gate","text":"<p>The CPhase gate applies a phase shift to the |11\u27e9 state.</p> <p>Matrix Representation:</p> <pre><code>CPhase(\u03c6) = [1 0 0      0     ]\n            [0 1 0      0     ]\n            [0 0 1      0     ]\n            [0 0 0  e^(i\u03c6)]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CPhase","title":"<code>skq.gates.qubit.multi.CPhase</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>General controlled phase shift gate. :param phi: The phase shift angle in radians.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CPhase(QubitGate):\n    \"\"\"General controlled phase shift gate.\n    :param phi: The phase shift angle in radians.\n    \"\"\"\n\n    def __new__(cls, phi: float):\n        obj = super().__new__(cls, [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, np.exp(1j * phi)]])\n        obj.phi = phi\n        return obj\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CPhaseGate:\n        return qiskit.circuit.library.CPhaseGate(self.phi)\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.CPhase:\n        assert len(wires) == 2, \"PennyLane CPhase gate requires 2 wires.\"\n        return qml.CPhase(phi=self.phi, wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 2, \"OpenQASM CPhase gate requires 2 qubits.\"\n        return f\"cp({self.phi}) q[{qubits[0]}], q[{qubits[1]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#controlled-s-cs-gate","title":"Controlled-S (CS) Gate","text":"<p>The CS gate is a special case of the CPhase gate with \u03c6 = \u03c0/2.</p> <p>Matrix Representation:</p> <pre><code>CS = [1 0 0 0]\n     [0 1 0 0]\n     [0 0 1 0]\n     [0 0 0 i]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CS","title":"<code>skq.gates.qubit.multi.CS</code>","text":"<p>               Bases: <code>CPhase</code></p> <p>Controlled-S gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CS(CPhase):\n    \"\"\"Controlled-S gate.\"\"\"\n\n    def __new__(cls):\n        phi = np.pi / 2\n        return super().__new__(cls, phi=phi)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CSGate:\n        return qiskit.circuit.library.CSGate()\n</code></pre>"},{"location":"api/gates-qubit/#controlled-t-ct-gate","title":"Controlled-T (CT) Gate","text":"<p>The CT gate is a special case of the CPhase gate with \u03c6 = \u03c0/4.</p> <p>Matrix Representation:</p> <pre><code>CT = [1 0 0      0     ]\n     [0 1 0      0     ]\n     [0 0 1      0     ]\n     [0 0 0  e^(i\u03c0/4)]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CT","title":"<code>skq.gates.qubit.multi.CT</code>","text":"<p>               Bases: <code>CPhase</code></p> <p>Controlled-T gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CT(CPhase):\n    \"\"\"Controlled-T gate.\"\"\"\n\n    def __new__(cls):\n        phi = np.pi / 4\n        return super().__new__(cls, phi=phi)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.TGate:\n        return qiskit.circuit.library.TGate().control(1)\n</code></pre>"},{"location":"api/gates-qubit/#swap-gate","title":"SWAP Gate","text":"<p>The SWAP gate exchanges the states of two qubits.</p> <p>Matrix Representation:</p> <pre><code>SWAP = [1 0 0 0]\n       [0 0 1 0]\n       [0 1 0 0]\n       [0 0 0 1]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.SWAP","title":"<code>skq.gates.qubit.multi.SWAP</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Swap gate. Swaps the states of two qubits.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class SWAP(QubitGate):\n    \"\"\"Swap gate. Swaps the states of two qubits.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.SwapGate:\n        return qiskit.circuit.library.SwapGate()\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.SWAP:\n        assert len(wires) == 2, \"PennyLane SWAP gate requires 2 wires.\"\n        return qml.SWAP(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 2, \"OpenQASM SWAP gate requires 2 qubits.\"\n        return f\"swap q[{qubits[0]}], q[{qubits[1]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#controlled-swap-cswap-gate","title":"Controlled-SWAP (CSWAP) Gate","text":"<p>The CSWAP gate, also known as the Fredkin gate, swaps two qubits if the control qubit is |1\u27e9.</p> <p>Matrix Representation:</p> <pre><code>CSWAP = [1 0 0 0 0 0 0 0]\n        [0 1 0 0 0 0 0 0]\n        [0 0 1 0 0 0 0 0]\n        [0 0 0 1 0 0 0 0]\n        [0 0 0 0 1 0 0 0]\n        [0 0 0 0 0 0 1 0]\n        [0 0 0 0 0 1 0 0]\n        [0 0 0 0 0 0 0 1]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CSwap","title":"<code>skq.gates.qubit.multi.CSwap</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>A controlled-SWAP gate. Also known as the Fredkin gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CSwap(QubitGate):\n    \"\"\"A controlled-SWAP gate. Also known as the Fredkin gate.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CSwapGate:\n        return qiskit.circuit.library.CSwapGate()\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.CSWAP:\n        return qml.CSWAP(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 3, \"OpenQASM CSWAP gate requires 3 qubits.\"\n        return f\"cswap q[{qubits[0]}], q[{qubits[1]}], q[{qubits[2]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#toffoli-ccx-gate","title":"Toffoli (CCX) Gate","text":"<p>The Toffoli gate, or CCX gate, applies an X gate to the target qubit if both control qubits are |1\u27e9.</p> <p>Matrix Representation:</p> <pre><code>CCX = [1 0 0 0 0 0 0 0]\n      [0 1 0 0 0 0 0 0]\n      [0 0 1 0 0 0 0 0]\n      [0 0 0 1 0 0 0 0]\n      [0 0 0 0 1 0 0 0]\n      [0 0 0 0 0 1 0 0]\n      [0 0 0 0 0 0 0 1]\n      [0 0 0 0 0 0 1 0]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CCX","title":"<code>skq.gates.qubit.multi.CCX</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>A 3-qubit controlled-controlled-X (CCX) gate. Also known as the Toffoli gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CCX(QubitGate):\n    \"\"\"A 3-qubit controlled-controlled-X (CCX) gate. Also known as the Toffoli gate.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CCXGate:\n        return qiskit.circuit.library.CCXGate()\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.Toffoli:\n        return qml.Toffoli(wires=wires)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 3, \"OpenQASM CCX (Toffoli) gate requires 3 qubits.\"\n        return f\"ccx q[{qubits[0]}], q[{qubits[1]}], q[{qubits[2]}];\"\n</code></pre>"},{"location":"api/gates-qubit/#ccy-gate","title":"CCY Gate","text":"<p>The CCY gate applies a Y gate to the target qubit if both control qubits are |1\u27e9.</p> <p>Matrix Representation:</p> <pre><code>CCY = [1 0 0 0 0 0 0    0   ]\n      [0 1 0 0 0 0 0    0   ]\n      [0 0 1 0 0 0 0    0   ]\n      [0 0 0 1 0 0 0    0   ]\n      [0 0 0 0 1 0 0    0   ]\n      [0 0 0 0 0 1 0    0   ]\n      [0 0 0 0 0 0 0   -i   ]\n      [0 0 0 0 0 0 i    0   ]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CCY","title":"<code>skq.gates.qubit.multi.CCY</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>A 3-qubit controlled-controlled-Y (CCY) gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CCY(QubitGate):\n    \"\"\"A 3-qubit controlled-controlled-Y (CCY) gate.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, -1j], [0, 0, 0, 0, 0, 0, 1j, 0]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.YGate:\n        # There is no native CCY gate in Qiskit so we construct it.\n        return qiskit.circuit.library.YGate().control(2)\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 3, \"OpenQASM CCY gate requires 3 qubits.\"\n        # Custom OpenQASM implementation\n        # sdg is an inverse s gate\n        return f\"\"\"sdg q[{qubits[2]}];\\ncx q[{qubits[1]}], q[{qubits[2]}];\\ns q[{qubits[2]}];\\ncx q[{qubits[0]}], q[{qubits[2]}];\\nsdg q[{qubits[2]}];\\ncx q[{qubits[1]}], q[{qubits[2]}];\\ns q[{qubits[2]}];\\ny q[{qubits[2]}];\"\"\"\n</code></pre>"},{"location":"api/gates-qubit/#ccz-gate","title":"CCZ Gate","text":"<p>The CCZ gate applies a Z gate to the target qubit if both control qubits are |1\u27e9.</p> <p>Matrix Representation:</p> <pre><code>CCZ = [1 0 0 0 0 0 0  0]\n      [0 1 0 0 0 0 0  0]\n      [0 0 1 0 0 0 0  0]\n      [0 0 0 1 0 0 0  0]\n      [0 0 0 0 1 0 0  0]\n      [0 0 0 0 0 1 0  0]\n      [0 0 0 0 0 0 1  0]\n      [0 0 0 0 0 0 0 -1]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CCZ","title":"<code>skq.gates.qubit.multi.CCZ</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>A 3-qubit controlled-controlled-Z (CCZ) gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CCZ(QubitGate):\n    \"\"\"A 3-qubit controlled-controlled-Z (CCZ) gate.\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [[1, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, -1]])\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CCZGate:\n        return qiskit.circuit.library.CCZGate()\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        assert len(qubits) == 3, \"OpenQASM CCZ gate requires 3 qubits.\"\n        # CCZ = CCX sandwiched between two H gates on last qubit.\n        return f\"\"\"h q[{qubits[2]}];\\nccx q[{qubits[0]}], q[{qubits[1]}], q[{qubits[2]}];\\nh q[{qubits[2]}];\"\"\"\n</code></pre>"},{"location":"api/gates-qubit/#multi-controlled-x-mcx-gate","title":"Multi-Controlled X (MCX) Gate","text":"<p>The MCX gate applies an X gate to the target qubit if all control qubits are |1\u27e9.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.MCX","title":"<code>skq.gates.qubit.multi.MCX</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Multi controlled-X (MCX) gate. :param num_ctrl_qubits: Number of control qubits.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class MCX(QubitGate):\n    \"\"\"\n    Multi controlled-X (MCX) gate.\n    :param num_ctrl_qubits: Number of control qubits.\n    \"\"\"\n\n    def __new__(cls, num_ctrl_qubits: int):\n        assert num_ctrl_qubits &gt;= 1, \"MCX gate must have at least one control qubit.\"\n        cls.num_ctrl_qubits = num_ctrl_qubits\n        levels = 2 ** (num_ctrl_qubits + 1)\n        gate = np.identity(levels)\n        gate[-2:, -2:] = X()\n        return super().__new__(cls, gate)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.CXGate | qiskit.circuit.library.CCXGate | qiskit.circuit.library.C3XGate | qiskit.circuit.library.C4XGate | qiskit.circuit.library.MCXGate:\n        if self.num_ctrl_qubits == 1:\n            return qiskit.circuit.library.CXGate()\n        elif self.num_ctrl_qubits == 2:\n            return qiskit.circuit.library.CCXGate()\n        elif self.num_ctrl_qubits == 3:\n            return qiskit.circuit.library.C3XGate()\n        elif self.num_ctrl_qubits == 4:\n            return qiskit.circuit.library.C4XGate()\n        else:\n            return qiskit.circuit.library.MCXGate(num_ctrl_qubits=self.num_ctrl_qubits)\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.CNOT | qml.QubitUnitary:\n        if self.num_ctrl_qubits == 1:\n            return qml.CNOT(wires=wires)\n        else:\n            return super().to_pennylane(wires)\n</code></pre>"},{"location":"api/gates-qubit/#multi-controlled-y-mcy-gate","title":"Multi-Controlled Y (MCY) Gate","text":"<p>The MCY gate applies a Y gate to the target qubit if all control qubits are |1\u27e9.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.MCY","title":"<code>skq.gates.qubit.multi.MCY</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Multi controlled-Y (MCY) gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class MCY(QubitGate):\n    \"\"\"Multi controlled-Y (MCY) gate.\"\"\"\n\n    def __new__(cls, num_ctrl_qubits: int):\n        assert num_ctrl_qubits &gt;= 1, \"MCY gate must have at least one control qubit.\"\n        cls.num_ctrl_qubits = num_ctrl_qubits\n        levels = 2 ** (num_ctrl_qubits + 1)\n        gate = np.identity(levels)\n        gate[-2:, -2:] = Y()\n        return super().__new__(cls, gate)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.YGate:\n        return qiskit.circuit.library.YGate().control(self.num_ctrl_qubits)\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.CY | qml.QubitUnitary:\n        if self.num_ctrl_qubits == 1:\n            return qml.CY(wires=wires)\n        else:\n            return super().to_pennylane(wires)\n</code></pre>"},{"location":"api/gates-qubit/#multi-controlled-z-mcz-gate","title":"Multi-Controlled Z (MCZ) Gate","text":"<p>The MCZ gate applies a Z gate to the target qubit if all control qubits are |1\u27e9.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.MCZ","title":"<code>skq.gates.qubit.multi.MCZ</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Multi controlled-Z (MCZ) gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class MCZ(QubitGate):\n    \"\"\"Multi controlled-Z (MCZ) gate.\"\"\"\n\n    def __new__(cls, num_ctrl_qubits: int):\n        assert num_ctrl_qubits &gt;= 1, \"MCZ gate must have at least one control qubit.\"\n        cls.num_ctrl_qubits = num_ctrl_qubits\n        levels = 2 ** (num_ctrl_qubits + 1)\n        gate = np.identity(levels)\n        gate[-2:, -2:] = Z()\n        return super().__new__(cls, gate)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.ZGate:\n        return qiskit.circuit.library.ZGate().control(self.num_ctrl_qubits)\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.CZ | qml.QubitUnitary:\n        if self.num_ctrl_qubits == 1:\n            return qml.CZ(wires=wires)\n        else:\n            return super().to_pennylane(wires)\n</code></pre>"},{"location":"api/gates-qubit/#quantum-fourier-transform-qft-gate","title":"Quantum Fourier Transform (QFT) Gate","text":"<p>The QFT gate implements the Quantum Fourier Transform, a key component in many quantum algorithms.</p> <p>Matrix Representation (for n=2):</p> <pre><code>QFT = 1/2 * [1  1  1  1]\n             [1  i -1 -i]\n             [1 -1  1 -1]\n             [1 -i -1  i]\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.QFT","title":"<code>skq.gates.qubit.multi.QFT</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>n-qubit Quantum Fourier Transform gate. :param n_qubits: The number of qubits in the system. :param inverse: Whether to use the inverse QFT. - For example, in Shor's algorithm we use the inverse QFT.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class QFT(QubitGate):\n    \"\"\"\n    n-qubit Quantum Fourier Transform gate.\n    :param n_qubits: The number of qubits in the system.\n    :param inverse: Whether to use the inverse QFT.\n    - For example, in Shor's algorithm we use the inverse QFT.\n    \"\"\"\n\n    def __new__(cls, n_qubits: int, inverse: bool = False):\n        dim = 2**n_qubits\n        matrix = np.zeros((dim, dim), dtype=complex)\n        # Use positive exponent for QFT, negative for QFT\u2020\n        sign = -1 if inverse else 1\n        omega = np.exp(sign * 2j * np.pi / dim)\n\n        for i in range(dim):\n            for j in range(dim):\n                matrix[i, j] = omega ** (i * j) / np.sqrt(dim)\n\n        instance = super().__new__(cls, matrix)\n        instance.inverse = inverse\n        return instance\n\n    def to_qiskit(self):\n        \"\"\"Convert to a Qiskit circuit implementing QFT or QFT\u2020.\"\"\"\n        n = self.num_qubits\n        name = \"QFT\u2020\" if self.inverse else \"QFT\"\n\n        def create_qft(n_qubits):\n            circuit = qiskit.QuantumCircuit(n_qubits, name=name)\n            for i in range(n_qubits):\n                circuit.h(i)\n                for j in range(i + 1, n_qubits):\n                    circuit.cp(2 * np.pi / 2 ** (j - i + 1), i, j)\n            return circuit\n\n        qc = create_qft(n)\n        if self.inverse:\n            qc = qc.inverse()\n        qc.name = name\n        return qc\n\n    def to_qasm(self, qubits: list[int]) -&gt; str:\n        \"\"\"Convert to OpenQASM code.\"\"\"\n        n = self.num_qubits\n        assert len(qubits) == n, f\"OpenQASM QFT requires {n} qubits.\"\n\n        name = \"QFT\u2020\" if self.inverse else \"QFT\"\n        qasm_str = f\"// {name} circuit (big-endian convention)\\n\"\n\n        if self.inverse:\n            for i in range(n // 2):\n                qasm_str += f\"swap q[{qubits[i]}], q[{qubits[n-i-1]}];\\n\"\n            for i in range(n - 1, -1, -1):\n                for j in range(n - 1, i, -1):\n                    angle = -np.pi / (2 ** (j - i))\n                    qasm_str += f\"cu1({angle}) q[{qubits[i]}], q[{qubits[j]}];\\n\"\n                qasm_str += f\"h q[{qubits[i]}];\\n\"\n        else:\n            for i in range(n):\n                qasm_str += f\"h q[{qubits[i]}];\\n\"\n                for j in range(i + 1, n):\n                    angle = np.pi / (2 ** (j - i))\n                    qasm_str += f\"cu1({angle}) q[{qubits[i]}], q[{qubits[j]}];\\n\"\n            for i in range(n // 2):\n                qasm_str += f\"swap q[{qubits[i]}], q[{qubits[n-i-1]}];\\n\"\n\n        qasm_str += f\"// End of {name} circuit\\n\"\n        return qasm_str\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.QFT.to_qasm","title":"<code>to_qasm(qubits)</code>","text":"<p>Convert to OpenQASM code.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>def to_qasm(self, qubits: list[int]) -&gt; str:\n    \"\"\"Convert to OpenQASM code.\"\"\"\n    n = self.num_qubits\n    assert len(qubits) == n, f\"OpenQASM QFT requires {n} qubits.\"\n\n    name = \"QFT\u2020\" if self.inverse else \"QFT\"\n    qasm_str = f\"// {name} circuit (big-endian convention)\\n\"\n\n    if self.inverse:\n        for i in range(n // 2):\n            qasm_str += f\"swap q[{qubits[i]}], q[{qubits[n-i-1]}];\\n\"\n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, i, -1):\n                angle = -np.pi / (2 ** (j - i))\n                qasm_str += f\"cu1({angle}) q[{qubits[i]}], q[{qubits[j]}];\\n\"\n            qasm_str += f\"h q[{qubits[i]}];\\n\"\n    else:\n        for i in range(n):\n            qasm_str += f\"h q[{qubits[i]}];\\n\"\n            for j in range(i + 1, n):\n                angle = np.pi / (2 ** (j - i))\n                qasm_str += f\"cu1({angle}) q[{qubits[i]}], q[{qubits[j]}];\\n\"\n        for i in range(n // 2):\n            qasm_str += f\"swap q[{qubits[i]}], q[{qubits[n-i-1]}];\\n\"\n\n    qasm_str += f\"// End of {name} circuit\\n\"\n    return qasm_str\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.QFT.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert to a Qiskit circuit implementing QFT or QFT\u2020.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>def to_qiskit(self):\n    \"\"\"Convert to a Qiskit circuit implementing QFT or QFT\u2020.\"\"\"\n    n = self.num_qubits\n    name = \"QFT\u2020\" if self.inverse else \"QFT\"\n\n    def create_qft(n_qubits):\n        circuit = qiskit.QuantumCircuit(n_qubits, name=name)\n        for i in range(n_qubits):\n            circuit.h(i)\n            for j in range(i + 1, n_qubits):\n                circuit.cp(2 * np.pi / 2 ** (j - i + 1), i, j)\n        return circuit\n\n    qc = create_qft(n)\n    if self.inverse:\n        qc = qc.inverse()\n    qc.name = name\n    return qc\n</code></pre>"},{"location":"api/gates-qubit/#deutsch-oracle","title":"Deutsch Oracle","text":"<p>The Deutsch Oracle implements the oracle for the Deutsch algorithm.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.DeutschOracle","title":"<code>skq.gates.qubit.multi.DeutschOracle</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Oracle for Deutsch algorithm with ancilla qubit. Implements |x,y\u27e9 -&gt; |x, y\u2295f(x)\u27e9</p> <p>:param f: Function that takes an integer x (0 or 1) and returns 0 or 1</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class DeutschOracle(QubitGate):\n    \"\"\"\n    Oracle for Deutsch algorithm with ancilla qubit.\n    Implements |x,y\u27e9 -&gt; |x, y\u2295f(x)\u27e9\n\n    :param f: Function that takes an integer x (0 or 1) and returns 0 or 1\n    \"\"\"\n\n    def __new__(cls, f):\n        matrix = np.zeros((4, 4))\n        for x in [0, 1]:\n            matrix[x * 2 + f(x), x * 2] = 1  # |x,0\u27e9 -&gt; |x,f(x)\u27e9\n            matrix[x * 2 + (1 - f(x)), x * 2 + 1] = 1  # |x,1\u27e9 -&gt; |x,1-f(x)\u27e9\n\n        return super().__new__(cls, matrix)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n        # Reverse the order of qubits for Qiskit's little-endian convention\n        return qiskit.circuit.library.UnitaryGate(self.convert_endianness(), label=\"DeutschOracle\")\n</code></pre>"},{"location":"api/gates-qubit/#deutsch-jozsa-oracle","title":"Deutsch-Jozsa Oracle","text":"<p>The Deutsch-Jozsa Oracle implements the oracle for the Deutsch-Jozsa algorithm.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.DeutschJozsaOracle","title":"<code>skq.gates.qubit.multi.DeutschJozsaOracle</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Oracle for Deutsch-Jozsa algorithm.</p> <p>For input x and output f(x), the oracle applies phase (-1)^f(x). - Constant function: f(x) is same for all x - Balanced function: f(x) = 1 for exactly half of inputs</p> <p>:param f: Function that takes an integer x (0 to 2^n-1) and returns 0 or 1 :param n_bits: Number of input bits</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class DeutschJozsaOracle(QubitGate):\n    \"\"\"\n    Oracle for Deutsch-Jozsa algorithm.\n\n    For input x and output f(x), the oracle applies phase (-1)^f(x).\n    - Constant function: f(x) is same for all x\n    - Balanced function: f(x) = 1 for exactly half of inputs\n\n    :param f: Function that takes an integer x (0 to 2^n-1) and returns 0 or 1\n    :param n_bits: Number of input bits\n    \"\"\"\n\n    def __new__(cls, f, n_bits: int):\n        n_states = 2**n_bits\n        outputs = [f(x) for x in range(n_states)]\n        if not all(v in [0, 1] for v in outputs):\n            raise ValueError(\"Function must return 0 or 1\")\n\n        ones = sum(outputs)\n        if ones != 0 and ones != n_states and ones != n_states // 2:\n            raise ValueError(\"Function must be constant or balanced\")\n\n        oracle_matrix = np.eye(n_states)\n        for x in range(n_states):\n            oracle_matrix[x, x] = (-1) ** f(x)\n\n        return super().__new__(cls, oracle_matrix)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n        # Reverse the order of qubits for Qiskit's little-endian convention\n        return qiskit.circuit.library.UnitaryGate(self.convert_endianness(), label=\"DeutschJozsaOracle\")\n</code></pre>"},{"location":"api/gates-qubit/#phase-oracle","title":"Phase Oracle","text":"<p>The Phase Oracle marks a target state with a phase shift, as used in Grover's search algorithm.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.PhaseOracle","title":"<code>skq.gates.qubit.multi.PhaseOracle</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Phase Oracle as used in Grover's search algorithm. :param target_state: The target state to mark. target_state is assumed to be in Big-Endian format.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class PhaseOracle(QubitGate):\n    \"\"\"\n    Phase Oracle as used in Grover's search algorithm.\n    :param target_state: The target state to mark.\n    target_state is assumed to be in Big-Endian format.\n    \"\"\"\n\n    def __new__(cls, target_state: np.ndarray):\n        state = Statevector(target_state)\n        n_qubits = state.num_qubits\n        identity = np.eye(2**n_qubits)\n        oracle_matrix = identity - 2 * np.outer(target_state, target_state.conj())\n        return super().__new__(cls, oracle_matrix)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n        # Reverse the order of qubits for Qiskit's little-endian convention\n        return qiskit.circuit.library.UnitaryGate(self.convert_endianness(), label=\"PhaseOracle\")\n</code></pre>"},{"location":"api/gates-qubit/#grover-diffusion-operator","title":"Grover Diffusion Operator","text":"<p>The Grover Diffusion Operator amplifies the amplitude of the marked state in Grover's search algorithm.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.GroverDiffusion","title":"<code>skq.gates.qubit.multi.GroverDiffusion</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Grover Diffusion Operator Gate as used in Grover's search algorithm. This gate amplifies the amplitude of the marked state. :param n_qubits: The number of qubits in the system.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class GroverDiffusion(QubitGate):\n    \"\"\"\n    Grover Diffusion Operator Gate as used in Grover's search algorithm.\n    This gate amplifies the amplitude of the marked state.\n    :param n_qubits: The number of qubits in the system.\n    \"\"\"\n\n    def __new__(cls, n_qubits: int):\n        assert n_qubits &gt;= 1, \"GroverDiffusionGate must have at least one qubit.\"\n        # Equal superposition state vector\n        size = 2**n_qubits\n        equal_superposition = np.ones(size) / np.sqrt(size)\n        # Grover diffusion operator: 2|\u03c8\u27e9\u27e8\u03c8| - I\n        diffusion_matrix = 2 * np.outer(equal_superposition, equal_superposition) - np.eye(size)\n        return super().__new__(cls, diffusion_matrix)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n        # Reverse the order of qubits for Qiskit's little-endian convention\n        return qiskit.circuit.library.UnitaryGate(self.convert_endianness(), label=\"GroverDiffusion\")\n</code></pre>"},{"location":"api/gates-qubit/#controlled-unitary-cu-gate","title":"Controlled Unitary (CU) Gate","text":"<p>The CU gate applies a unitary operation conditionally based on a control qubit.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CU","title":"<code>skq.gates.qubit.multi.CU</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>General Controlled-Unitary gate. Applies a unitary operation conditionally based on a control qubit. If the control qubit is |1&gt;, the unitary is applied to the target qubit(s). Only use this for custom unitaries. Else use standard controlled gates like CX, CY, CZ, CH, CS, CT, CPhase, etc.</p> <p>:param unitary: The unitary gate to be controlled. Must be a QubitGate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CU(QubitGate):\n    \"\"\"\n    General Controlled-Unitary gate.\n    Applies a unitary operation conditionally based on a control qubit.\n    If the control qubit is |1&gt;, the unitary is applied to the target qubit(s).\n    Only use this for custom unitaries. Else use standard controlled gates like CX, CY, CZ, CH, CS, CT, CPhase, etc.\n\n    :param unitary: The unitary gate to be controlled. Must be a QubitGate.\n    \"\"\"\n\n    def __new__(cls, unitary: QubitGate):\n        assert isinstance(unitary, QubitGate), \"Input must be a QubitGate\"\n\n        n_target_qubits = unitary.num_qubits\n        dim = 2 ** (n_target_qubits + 1)\n        matrix = np.eye(dim, dtype=complex)\n        block_size = 2**n_target_qubits\n        matrix[block_size:, block_size:] = unitary\n        obj = super().__new__(cls, matrix)\n        obj.unitary = unitary\n        obj.n_target_qubits = n_target_qubits\n        return obj\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n        try:\n            base_gate = self.unitary.to_qiskit()\n            return base_gate.control(1)\n        except (AttributeError, TypeError, ValueError):\n            return qiskit.circuit.library.UnitaryGate(self.convert_endianness(), label=f\"c-{self.unitary.__class__.__name__}\")\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.QubitUnitary:\n        \"\"\"Convert to a PennyLane controlled gate.\"\"\"\n        assert len(wires) == self.num_qubits, f\"PennyLane CU gate requires {self.num_qubits} wires.\"\n        return qml.QubitUnitary(self, wires=wires)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CU.to_pennylane","title":"<code>to_pennylane(wires)</code>","text":"<p>Convert to a PennyLane controlled gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>def to_pennylane(self, wires: list[int]) -&gt; qml.QubitUnitary:\n    \"\"\"Convert to a PennyLane controlled gate.\"\"\"\n    assert len(wires) == self.num_qubits, f\"PennyLane CU gate requires {self.num_qubits} wires.\"\n    return qml.QubitUnitary(self, wires=wires)\n</code></pre>"},{"location":"api/gates-qubit/#multi-controlled-unitary-mcu-gate","title":"Multi-Controlled Unitary (MCU) Gate","text":"<p>The MCU gate applies a unitary operation conditionally based on multiple control qubits.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.MCU","title":"<code>skq.gates.qubit.multi.MCU</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Multi-Controlled Unitary gate. Applies a unitary operation conditionally based on multiple control qubits. The unitary is applied to target qubit(s) only if all control qubits are |1&gt;. Only use this for custom unitaries. Else use standard controlled gates like CX, CY, CZ, CH, CS, CT, CPhase, etc.</p> <p>:param unitary: The unitary gate to be controlled. Must be a QubitGate. :param num_ctrl_qubits: Number of control qubits.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class MCU(QubitGate):\n    \"\"\"\n    Multi-Controlled Unitary gate.\n    Applies a unitary operation conditionally based on multiple control qubits.\n    The unitary is applied to target qubit(s) only if all control qubits are |1&gt;.\n    Only use this for custom unitaries. Else use standard controlled gates like CX, CY, CZ, CH, CS, CT, CPhase, etc.\n\n\n    :param unitary: The unitary gate to be controlled. Must be a QubitGate.\n    :param num_ctrl_qubits: Number of control qubits.\n    \"\"\"\n\n    def __new__(cls, unitary: QubitGate, num_ctrl_qubits: int):\n        assert isinstance(unitary, QubitGate), \"Input must be a QubitGate\"\n        assert num_ctrl_qubits &gt;= 1, \"MCU gate must have at least one control qubit.\"\n        n_target_qubits = unitary.num_qubits\n        total_qubits = n_target_qubits + num_ctrl_qubits\n        dim = 2**total_qubits\n        matrix = np.eye(dim, dtype=complex)\n        unitary_size = 2**n_target_qubits\n        start_idx = dim - unitary_size\n        matrix[start_idx:, start_idx:] = unitary\n\n        obj = super().__new__(cls, matrix)\n        obj.unitary = unitary\n        obj.num_ctrl_qubits = num_ctrl_qubits\n        obj.n_target_qubits = n_target_qubits\n        return obj\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n        \"\"\"Convert to a Qiskit controlled gate.\"\"\"\n        try:\n            base_gate = self.unitary.to_qiskit()\n            return base_gate.control(self.num_ctrl_qubits)\n        except (AttributeError, TypeError, ValueError):\n            return qiskit.circuit.library.UnitaryGate(self.convert_endianness(), label=f\"mc-{self.unitary.__class__.__name__}\")\n\n    def to_pennylane(self, wires: list[int]) -&gt; qml.QubitUnitary:\n        \"\"\"Convert to a PennyLane multi-controlled gate.\"\"\"\n        assert len(wires) == self.num_qubits, f\"PennyLane MCU gate requires {self.num_qubits} wires.\"\n        return qml.QubitUnitary(self, wires=wires)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.MCU.to_pennylane","title":"<code>to_pennylane(wires)</code>","text":"<p>Convert to a PennyLane multi-controlled gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>def to_pennylane(self, wires: list[int]) -&gt; qml.QubitUnitary:\n    \"\"\"Convert to a PennyLane multi-controlled gate.\"\"\"\n    assert len(wires) == self.num_qubits, f\"PennyLane MCU gate requires {self.num_qubits} wires.\"\n    return qml.QubitUnitary(self, wires=wires)\n</code></pre>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.MCU.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert to a Qiskit controlled gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n    \"\"\"Convert to a Qiskit controlled gate.\"\"\"\n    try:\n        base_gate = self.unitary.to_qiskit()\n        return base_gate.control(self.num_ctrl_qubits)\n    except (AttributeError, TypeError, ValueError):\n        return qiskit.circuit.library.UnitaryGate(self.convert_endianness(), label=f\"mc-{self.unitary.__class__.__name__}\")\n</code></pre>"},{"location":"api/gates-qubit/#cross-resonance-cr-gate","title":"Cross-Resonance (CR) Gate","text":"<p>The CR gate is a simple Cross-Resonance gate used in superconducting qubit architectures.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.CR","title":"<code>skq.gates.qubit.multi.CR</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Simple Cross-Resonance gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class CR(QubitGate):\n    \"\"\"Simple Cross-Resonance gate.\"\"\"\n\n    def __new__(cls, theta: float):\n        return super().__new__(cls, [[1, 0, 0, 0], [0, np.cos(theta), 0, -1j * np.sin(theta)], [0, 0, 1, 0], [0, -1j * np.sin(theta), 0, np.cos(theta)]])\n</code></pre>"},{"location":"api/gates-qubit/#symmetric-echoed-cross-resonance-symmetricecr-gate","title":"Symmetric Echoed Cross-Resonance (SymmetricECR) Gate","text":"<p>The SymmetricECR gate is a symmetric echoed Cross-Resonance gate.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.SymmetricECR","title":"<code>skq.gates.qubit.multi.SymmetricECR</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Symmetric Echoed Cross-Resonance gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class SymmetricECR(QubitGate):\n    \"\"\"Symmetric Echoed Cross-Resonance gate.\"\"\"\n\n    def __new__(cls, theta: float):\n        return super().__new__(cls, CR(theta) @ CR(-theta))\n</code></pre>"},{"location":"api/gates-qubit/#asymmetric-echoed-cross-resonance-asymmetricecr-gate","title":"Asymmetric Echoed Cross-Resonance (AsymmetricECR) Gate","text":"<p>The AsymmetricECR gate is an asymmetric echoed Cross-Resonance gate.</p>"},{"location":"api/gates-qubit/#skq.gates.qubit.multi.AsymmetricECR","title":"<code>skq.gates.qubit.multi.AsymmetricECR</code>","text":"<p>               Bases: <code>QubitGate</code></p> <p>Asymmetric Echoed Cross-Resonance gate.</p> Source code in <code>src/skq/gates/qubit/multi.py</code> <pre><code>class AsymmetricECR(QubitGate):\n    \"\"\"Asymmetric Echoed Cross-Resonance gate.\"\"\"\n\n    def __new__(cls, theta1: float, theta2: float):\n        return super().__new__(cls, CR(theta1) @ CR(theta2))\n</code></pre>"},{"location":"api/gates-qupent/","title":"Qupent Gates API Reference","text":"<p>This page documents the qupent gates available in the <code>skq.gates.qupent</code> module. Qupents are quantum systems with 5 basis states (|0\u27e9, |1\u27e9, |2\u27e9, |3\u27e9, |4\u27e9) and can model spin-2 particles like the graviton.</p>"},{"location":"api/gates-qupent/#qupent-gate-base-class","title":"Qupent Gate Base Class","text":"<p>The <code>QupentGate</code> class serves as the foundation for all qupent-based quantum gates in SKQ.</p>"},{"location":"api/gates-qupent/#skq.gates.qupent.base.QupentGate","title":"<code>skq.gates.qupent.base.QupentGate</code>","text":"<p>               Bases: <code>BaseGate</code></p> <p>Base class for Qupent gates. These are quantum systems with a basis of 5 states. |0&gt;, |1&gt;, |2&gt;, |3&gt;, |4&gt;. Models spin-2 particles like the graviton.</p> Source code in <code>src/skq/gates/qupent/base.py</code> <pre><code>class QupentGate(BaseGate):\n    \"\"\"\n    Base class for Qupent gates.\n    These are quantum systems with a basis of 5 states. |0&gt;, |1&gt;, |2&gt;, |3&gt;, |4&gt;.\n    Models spin-2 particles like the graviton.\n    \"\"\"\n\n    def __new__(cls, input_array):\n        obj = super().__new__(cls, input_array)\n        assert obj.is_at_least_nxn(n=5), \"Gate must be at least a 5x5 matrix\"\n        assert obj.is_power_of_n_shape(n=5), \"Gate shape must be a power of 5\"\n        return obj\n\n    def num_qupents(self) -&gt; int:\n        \"\"\"Return the number of qupents involved in the gate.\"\"\"\n        return int(np.log(self.shape[0]) / np.log(5))\n\n    def is_multi_qupent(self) -&gt; bool:\n        \"\"\"Check if the gate involves multiple qupents.\"\"\"\n        return self.num_qupents() &gt; 1\n</code></pre>"},{"location":"api/gates-qupent/#skq.gates.qupent.base.QupentGate.is_multi_qupent","title":"<code>is_multi_qupent()</code>","text":"<p>Check if the gate involves multiple qupents.</p> Source code in <code>src/skq/gates/qupent/base.py</code> <pre><code>def is_multi_qupent(self) -&gt; bool:\n    \"\"\"Check if the gate involves multiple qupents.\"\"\"\n    return self.num_qupents() &gt; 1\n</code></pre>"},{"location":"api/gates-qupent/#skq.gates.qupent.base.QupentGate.num_qupents","title":"<code>num_qupents()</code>","text":"<p>Return the number of qupents involved in the gate.</p> Source code in <code>src/skq/gates/qupent/base.py</code> <pre><code>def num_qupents(self) -&gt; int:\n    \"\"\"Return the number of qupents involved in the gate.\"\"\"\n    return int(np.log(self.shape[0]) / np.log(5))\n</code></pre>"},{"location":"api/gates-qupent/#single-qupent-gates","title":"Single-Qupent Gates","text":""},{"location":"api/gates-qupent/#identity-gate-qupenti","title":"Identity Gate (QupentI)","text":"<p>The Identity gate leaves the qupent state unchanged.</p> <p>Matrix Representation:</p> \\[ \\text{QupentI} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} \\]"},{"location":"api/gates-qupent/#skq.gates.qupent.single.QupentI","title":"<code>skq.gates.qupent.single.QupentI</code>","text":"<p>               Bases: <code>QupentGate</code></p> <p>Identity gate for qupents.</p> Source code in <code>src/skq/gates/qupent/single.py</code> <pre><code>class QupentI(QupentGate):\n    \"\"\"Identity gate for qupents.\"\"\"\n\n    def __new__(cls):\n        obj = super().__new__(cls, np.eye(5))\n        return obj\n</code></pre>"},{"location":"api/gates-qupent/#x-gate-qupentx","title":"X Gate (QupentX)","text":"<p>The X gate for a qupent performs a cyclic permutation of the basis states: |0\u27e9 \u2192 |1\u27e9 \u2192 |2\u27e9 \u2192 |3\u27e9 \u2192 |4\u27e9 \u2192 |0\u27e9.</p> <p>Matrix Representation:</p> \\[ \\text{QupentX} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\end{pmatrix} \\]"},{"location":"api/gates-qupent/#skq.gates.qupent.single.QupentX","title":"<code>skq.gates.qupent.single.QupentX</code>","text":"<p>               Bases: <code>QupentGate</code></p> <p>X gate for qupents.</p> Source code in <code>src/skq/gates/qupent/single.py</code> <pre><code>class QupentX(QupentGate):\n    \"\"\"X gate for qupents.\"\"\"\n\n    def __new__(cls):\n        obj = super().__new__(cls, np.array([[0, 0, 0, 0, 1], [1, 0, 0, 0, 0], [0, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 0]]))\n        return obj\n</code></pre>"},{"location":"api/gates-qupent/#z-gate-qupentz","title":"Z Gate (QupentZ)","text":"<p>The Z gate for a qupent applies different phases to each basis state, using the fifth roots of unity.</p> <p>Matrix Representation:</p> \\[ \\text{QupentZ} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; e^{2\\pi i/5} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; e^{4\\pi i/5} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; e^{6\\pi i/5} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; e^{8\\pi i/5} \\end{pmatrix} \\] <p>Where \\(e^{2\\pi i/5}\\) is the fifth root of unity.</p>"},{"location":"api/gates-qupent/#skq.gates.qupent.single.QupentZ","title":"<code>skq.gates.qupent.single.QupentZ</code>","text":"<p>               Bases: <code>QupentGate</code></p> <p>Z gate for qupents.</p> Source code in <code>src/skq/gates/qupent/single.py</code> <pre><code>class QupentZ(QupentGate):\n    \"\"\"Z gate for qupents.\"\"\"\n\n    def __new__(cls):\n        d = 5\n        omega = np.exp(2j * np.pi / d)\n        phases = [omega**k for k in range(d)]\n        obj = super().__new__(cls, np.diag(phases))\n        return obj\n</code></pre>"},{"location":"api/gates-qupent/#hadamard-gate-qupenth","title":"Hadamard Gate (QupentH)","text":"<p>The Hadamard gate for a qupent creates a superposition of the five basis states with different phases.</p> <p>Matrix Representation:</p> \\[ \\text{QupentH} = \\frac{1}{\\sqrt{5}} \\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; e^{2\\pi i/5} &amp; e^{4\\pi i/5} &amp; e^{6\\pi i/5} &amp; e^{8\\pi i/5} \\\\ 1 &amp; e^{4\\pi i/5} &amp; e^{8\\pi i/5} &amp; e^{2\\pi i/5} &amp; e^{6\\pi i/5} \\\\ 1 &amp; e^{6\\pi i/5} &amp; e^{2\\pi i/5} &amp; e^{8\\pi i/5} &amp; e^{4\\pi i/5} \\\\ 1 &amp; e^{8\\pi i/5} &amp; e^{6\\pi i/5} &amp; e^{4\\pi i/5} &amp; e^{2\\pi i/5} \\end{pmatrix} \\] <p>This is a generalized Fourier transform matrix for dimension 5.</p>"},{"location":"api/gates-qupent/#skq.gates.qupent.single.QupentH","title":"<code>skq.gates.qupent.single.QupentH</code>","text":"<p>               Bases: <code>QupentGate</code></p> <p>Hadamard gate for qupents.</p> Source code in <code>src/skq/gates/qupent/single.py</code> <pre><code>class QupentH(QupentGate):\n    \"\"\"Hadamard gate for qupents.\"\"\"\n\n    def __new__(cls):\n        obj = super().__new__(\n            cls,\n            np.array(\n                [\n                    [1, 1, 1, 1, 1],\n                    [1, np.exp(2j * np.pi / 5), np.exp(4j * np.pi / 5), np.exp(6j * np.pi / 5), np.exp(8j * np.pi / 5)],\n                    [1, np.exp(4j * np.pi / 5), np.exp(8j * np.pi / 5), np.exp(2j * np.pi / 5), np.exp(6j * np.pi / 5)],\n                    [1, np.exp(6j * np.pi / 5), np.exp(2j * np.pi / 5), np.exp(8j * np.pi / 5), np.exp(4j * np.pi / 5)],\n                    [1, np.exp(8j * np.pi / 5), np.exp(6j * np.pi / 5), np.exp(4j * np.pi / 5), np.exp(2j * np.pi / 5)],\n                ]\n            )\n            / np.sqrt(5),\n        )\n        return obj\n</code></pre>"},{"location":"api/gates-qupent/#t-gate-qupentt","title":"T Gate (QupentT)","text":"<p>The T gate for a qupent applies smaller phase shifts than the Z gate.</p> <p>Matrix Representation:</p> \\[ \\text{QupentT} = \\begin{pmatrix} e^{0\\pi i/10} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; e^{\\pi i/10} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; e^{2\\pi i/10} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; e^{3\\pi i/10} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; e^{4\\pi i/10} \\end{pmatrix} \\]"},{"location":"api/gates-qupent/#skq.gates.qupent.single.QupentT","title":"<code>skq.gates.qupent.single.QupentT</code>","text":"<p>               Bases: <code>QupentGate</code></p> <p>T gate for qupents.</p> Source code in <code>src/skq/gates/qupent/single.py</code> <pre><code>class QupentT(QupentGate):\n    \"\"\"T gate for qupents.\"\"\"\n\n    def __new__(cls):\n        phases = [np.exp(1j * k * np.pi / 10) for k in range(5)]\n        obj = super().__new__(cls, np.diag(phases))\n        return obj\n</code></pre>"},{"location":"api/gates-ququart/","title":"Ququart Gates API Reference","text":"<p>This page documents the ququart gates available in the <code>skq.gates.ququart</code> module. Ququarts are quantum systems with 4 basis states (|0\u27e9, |1\u27e9, |2\u27e9, |3\u27e9) and can model spin-3/2 particles.</p>"},{"location":"api/gates-ququart/#ququart-gate-base-class","title":"Ququart Gate Base Class","text":"<p>The <code>QuquartGate</code> class serves as the foundation for all ququart-based quantum gates in SKQ.</p>"},{"location":"api/gates-ququart/#skq.gates.ququart.base.QuquartGate","title":"<code>skq.gates.ququart.base.QuquartGate</code>","text":"<p>               Bases: <code>BaseGate</code></p> <p>Base class for Ququart gates. These are quantum systems with a basis of 4 states. |0&gt;, |1&gt;, |2&gt;, |3&gt;. Models spin-1/2 particles like electrons.</p> Source code in <code>src/skq/gates/ququart/base.py</code> <pre><code>class QuquartGate(BaseGate):\n    \"\"\"\n    Base class for Ququart gates.\n    These are quantum systems with a basis of 4 states. |0&gt;, |1&gt;, |2&gt;, |3&gt;.\n    Models spin-1/2 particles like electrons.\n    \"\"\"\n\n    def __new__(cls, input_array):\n        obj = super().__new__(cls, input_array)\n        assert obj.is_at_least_nxn(n=4), \"Gate must be at least a 4x4 matrix\"\n        assert obj.is_power_of_n_shape(n=4), \"Gate shape must be a power of 4\"\n        return obj\n\n    def num_qudits(self) -&gt; int:\n        \"\"\"Return the number of qudits involved in the gate.\"\"\"\n        return int(np.log(self.shape[0]) / np.log(4))\n\n    def is_multi_qudit(self) -&gt; bool:\n        \"\"\"Check if the gate involves multiple qudits.\"\"\"\n        return self.num_qudits() &gt; 1\n</code></pre>"},{"location":"api/gates-ququart/#skq.gates.ququart.base.QuquartGate.is_multi_qudit","title":"<code>is_multi_qudit()</code>","text":"<p>Check if the gate involves multiple qudits.</p> Source code in <code>src/skq/gates/ququart/base.py</code> <pre><code>def is_multi_qudit(self) -&gt; bool:\n    \"\"\"Check if the gate involves multiple qudits.\"\"\"\n    return self.num_qudits() &gt; 1\n</code></pre>"},{"location":"api/gates-ququart/#skq.gates.ququart.base.QuquartGate.num_qudits","title":"<code>num_qudits()</code>","text":"<p>Return the number of qudits involved in the gate.</p> Source code in <code>src/skq/gates/ququart/base.py</code> <pre><code>def num_qudits(self) -&gt; int:\n    \"\"\"Return the number of qudits involved in the gate.\"\"\"\n    return int(np.log(self.shape[0]) / np.log(4))\n</code></pre>"},{"location":"api/gates-ququart/#single-ququart-gates","title":"Single-Ququart Gates","text":""},{"location":"api/gates-ququart/#identity-gate-ququarti","title":"Identity Gate (QuquartI)","text":"<p>The Identity gate leaves the ququart state unchanged.</p> <p>Matrix Representation:</p> \\[ \\text{QuquartI} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} \\]"},{"location":"api/gates-ququart/#skq.gates.ququart.single.QuquartI","title":"<code>skq.gates.ququart.single.QuquartI</code>","text":"<p>               Bases: <code>QuquartGate</code></p> <p>Identity gate for ququarts.</p> Source code in <code>src/skq/gates/ququart/single.py</code> <pre><code>class QuquartI(QuquartGate):\n    \"\"\"Identity gate for ququarts.\"\"\"\n\n    def __new__(cls):\n        obj = super().__new__(cls, np.eye(4))\n        return obj\n</code></pre>"},{"location":"api/gates-ququart/#x-gate-ququartx","title":"X Gate (QuquartX)","text":"<p>The X gate for a ququart performs a cyclic permutation of the basis states: |0\u27e9 \u2192 |1\u27e9 \u2192 |2\u27e9 \u2192 |3\u27e9 \u2192 |0\u27e9.</p> <p>Matrix Representation:</p> \\[ \\text{QuquartX} = \\begin{pmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{pmatrix} \\]"},{"location":"api/gates-ququart/#skq.gates.ququart.single.QuquartX","title":"<code>skq.gates.ququart.single.QuquartX</code>","text":"<p>               Bases: <code>QuquartGate</code></p> <p>X gate for ququarts.</p> Source code in <code>src/skq/gates/ququart/single.py</code> <pre><code>class QuquartX(QuquartGate):\n    \"\"\"X gate for ququarts.\"\"\"\n\n    def __new__(cls):\n        obj = super().__new__(cls, np.array([[0, 0, 0, 1], [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]]))\n        return obj\n</code></pre>"},{"location":"api/gates-ququart/#z-gate-ququartz","title":"Z Gate (QuquartZ)","text":"<p>The Z gate for a ququart applies different phases to each basis state.</p> <p>Matrix Representation:</p> \\[ \\text{QuquartZ} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; i &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; -1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; -i \\end{pmatrix} \\]"},{"location":"api/gates-ququart/#skq.gates.ququart.single.QuquartZ","title":"<code>skq.gates.ququart.single.QuquartZ</code>","text":"<p>               Bases: <code>QuquartGate</code></p> <p>Z gate for ququarts.</p> Source code in <code>src/skq/gates/ququart/single.py</code> <pre><code>class QuquartZ(QuquartGate):\n    \"\"\"Z gate for ququarts.\"\"\"\n\n    def __new__(cls):\n        obj = super().__new__(cls, np.array([[1, 0, 0, 0], [0, 1j, 0, 0], [0, 0, -1, 0], [0, 0, 0, -1j]]))\n        return obj\n</code></pre>"},{"location":"api/gates-ququart/#hadamard-gate-ququarth","title":"Hadamard Gate (QuquartH)","text":"<p>The Hadamard gate for a ququart creates a superposition of the four basis states with different phases.</p> <p>Matrix Representation:</p> \\[ \\text{QuquartH} = \\frac{1}{2} \\begin{pmatrix} 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; i &amp; -1 &amp; -i \\\\ 1 &amp; -1 &amp; 1 &amp; -1 \\\\ 1 &amp; -i &amp; -1 &amp; i \\end{pmatrix} \\]"},{"location":"api/gates-ququart/#skq.gates.ququart.single.QuquartH","title":"<code>skq.gates.ququart.single.QuquartH</code>","text":"<p>               Bases: <code>QuquartGate</code></p> <p>Hadamard gate for ququarts.</p> Source code in <code>src/skq/gates/ququart/single.py</code> <pre><code>class QuquartH(QuquartGate):\n    \"\"\"Hadamard gate for ququarts.\"\"\"\n\n    def __new__(cls):\n        obj = super().__new__(cls, np.array([[1, 1, 1, 1], [1, 1j, -1, -1j], [1, -1, 1, -1], [1, -1j, -1, 1j]]) / 2)\n        return obj\n</code></pre>"},{"location":"api/gates-ququart/#t-gate-ququartt","title":"T Gate (QuquartT)","text":"<p>The T gate for a ququart applies a phase shift to the |1\u27e9 state.</p> <p>Matrix Representation:</p> \\[ \\text{QuquartT} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; e^{i\\pi/4} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} \\]"},{"location":"api/gates-ququart/#skq.gates.ququart.single.QuquartT","title":"<code>skq.gates.ququart.single.QuquartT</code>","text":"<p>               Bases: <code>QuquartGate</code></p> <p>T gate for ququarts.</p> Source code in <code>src/skq/gates/ququart/single.py</code> <pre><code>class QuquartT(QuquartGate):\n    \"\"\"T gate for ququarts.\"\"\"\n\n    def __new__(cls):\n        obj = super().__new__(cls, np.diag([1, np.exp(1j * np.pi / 4), 1, 1]))\n        return obj\n</code></pre>"},{"location":"api/gates-qutrit/","title":"Qutrit Gates API Reference","text":"<p>This page documents the qutrit gates available in the <code>skq.gates.qutrit</code> module. Qutrits are quantum systems with 3 basis states (|0\u27e9, |1\u27e9, |2\u27e9) and can model spin-1 particles like photons and gluons.</p>"},{"location":"api/gates-qutrit/#qutrit-gate-base-class","title":"Qutrit Gate Base Class","text":"<p>The <code>QutritGate</code> class serves as the foundation for all qutrit-based quantum gates in SKQ.</p>"},{"location":"api/gates-qutrit/#skq.gates.qutrit.base.QutritGate","title":"<code>skq.gates.qutrit.base.QutritGate</code>","text":"<p>               Bases: <code>BaseGate</code></p> <p>Base class for Qutrit gates. These are quantum systems with a basis of 3 states. |0&gt;, |1&gt;, |2&gt;. Models spin-1 particles like photons and gluons.</p> Source code in <code>src/skq/gates/qutrit/base.py</code> <pre><code>class QutritGate(BaseGate):\n    \"\"\"\n    Base class for Qutrit gates.\n    These are quantum systems with a basis of 3 states. |0&gt;, |1&gt;, |2&gt;.\n    Models spin-1 particles like photons and gluons.\n    \"\"\"\n\n    def __new__(cls, input_array: np.array):\n        obj = super().__new__(cls, input_array)\n        assert obj.is_at_least_nxn(n=3), \"Gate must be at least a 3x3 matrix\"\n        assert obj.is_power_of_n_shape(n=3), \"Gate shape must be a power of 3\"\n        return obj\n\n    def num_qutrits(self) -&gt; int:\n        \"\"\"Return the number of qutrits involved in the gate.\"\"\"\n        return int(np.log(self.shape[0]) / np.log(3))\n\n    def is_multi_qutrit(self) -&gt; bool:\n        \"\"\"Check if the gate involves multiple qutrits.\"\"\"\n        return self.num_qutrits() &gt; 1\n\n    def qutrit_to_qubit(self) -&gt; CustomQubitGate:\n        \"\"\"\n        Convert the qutrit gate to an equivalent qubit gate.\n        :return: CustomQubitGate object\n        \"\"\"\n        num_qutrits = self.num_qutrits()\n        dim_qutrit = 3**num_qutrits\n        num_qubits = int(np.ceil(num_qutrits * np.log2(3)))\n        dim_qubit = 2**num_qubits\n        qubit_gate = np.eye(dim_qubit, dtype=complex)\n        qubit_gate[:dim_qutrit, :dim_qutrit] = self\n        return CustomQubitGate(qubit_gate)\n\n    def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n        \"\"\"\n        Convert Qutrit gate to a Qiskit Gate object.\n        Qiskit only supports qubit gates, so we convert the qutrit gate to a qubit gate first.\n        :return: Qiskit UnitaryGate object\n        \"\"\"\n        qubit_gate = self.qutrit_to_qubit()\n        return qubit_gate.to_qiskit()\n\n    def to_pennylane(self, wires: list[int] | int = None, qutrit_gate=False) -&gt; qml.QubitUnitary | qml.QutritUnitary:\n        \"\"\"\n        Convert gate to a PennyLane QubitUnitary.\n        PennyLane only supports qubit gates, so we convert the qutrit gate to a qubit gate first.\n        :param wires: List of wires the gate acts on\n        :param qutrit_gate: If True, return a QutritUnitary gate instead of a qubit gate\n        :return:\n        If qutrit_gate is True, return a PennyLane QutritUnitary object.\n        If qutrit_gate is False, return a PennyLane QubitUnitary object.\n        \"\"\"\n        if qutrit_gate:\n            return qml.QutritUnitary(self, wires=wires)\n        else:\n            return self.qutrit_to_qubit().to_pennylane(wires=wires)\n</code></pre>"},{"location":"api/gates-qutrit/#skq.gates.qutrit.base.QutritGate.is_multi_qutrit","title":"<code>is_multi_qutrit()</code>","text":"<p>Check if the gate involves multiple qutrits.</p> Source code in <code>src/skq/gates/qutrit/base.py</code> <pre><code>def is_multi_qutrit(self) -&gt; bool:\n    \"\"\"Check if the gate involves multiple qutrits.\"\"\"\n    return self.num_qutrits() &gt; 1\n</code></pre>"},{"location":"api/gates-qutrit/#skq.gates.qutrit.base.QutritGate.num_qutrits","title":"<code>num_qutrits()</code>","text":"<p>Return the number of qutrits involved in the gate.</p> Source code in <code>src/skq/gates/qutrit/base.py</code> <pre><code>def num_qutrits(self) -&gt; int:\n    \"\"\"Return the number of qutrits involved in the gate.\"\"\"\n    return int(np.log(self.shape[0]) / np.log(3))\n</code></pre>"},{"location":"api/gates-qutrit/#skq.gates.qutrit.base.QutritGate.qutrit_to_qubit","title":"<code>qutrit_to_qubit()</code>","text":"<p>Convert the qutrit gate to an equivalent qubit gate. :return: CustomQubitGate object</p> Source code in <code>src/skq/gates/qutrit/base.py</code> <pre><code>def qutrit_to_qubit(self) -&gt; CustomQubitGate:\n    \"\"\"\n    Convert the qutrit gate to an equivalent qubit gate.\n    :return: CustomQubitGate object\n    \"\"\"\n    num_qutrits = self.num_qutrits()\n    dim_qutrit = 3**num_qutrits\n    num_qubits = int(np.ceil(num_qutrits * np.log2(3)))\n    dim_qubit = 2**num_qubits\n    qubit_gate = np.eye(dim_qubit, dtype=complex)\n    qubit_gate[:dim_qutrit, :dim_qutrit] = self\n    return CustomQubitGate(qubit_gate)\n</code></pre>"},{"location":"api/gates-qutrit/#skq.gates.qutrit.base.QutritGate.to_pennylane","title":"<code>to_pennylane(wires=None, qutrit_gate=False)</code>","text":"<p>Convert gate to a PennyLane QubitUnitary. PennyLane only supports qubit gates, so we convert the qutrit gate to a qubit gate first. :param wires: List of wires the gate acts on :param qutrit_gate: If True, return a QutritUnitary gate instead of a qubit gate :return: If qutrit_gate is True, return a PennyLane QutritUnitary object. If qutrit_gate is False, return a PennyLane QubitUnitary object.</p> Source code in <code>src/skq/gates/qutrit/base.py</code> <pre><code>def to_pennylane(self, wires: list[int] | int = None, qutrit_gate=False) -&gt; qml.QubitUnitary | qml.QutritUnitary:\n    \"\"\"\n    Convert gate to a PennyLane QubitUnitary.\n    PennyLane only supports qubit gates, so we convert the qutrit gate to a qubit gate first.\n    :param wires: List of wires the gate acts on\n    :param qutrit_gate: If True, return a QutritUnitary gate instead of a qubit gate\n    :return:\n    If qutrit_gate is True, return a PennyLane QutritUnitary object.\n    If qutrit_gate is False, return a PennyLane QubitUnitary object.\n    \"\"\"\n    if qutrit_gate:\n        return qml.QutritUnitary(self, wires=wires)\n    else:\n        return self.qutrit_to_qubit().to_pennylane(wires=wires)\n</code></pre>"},{"location":"api/gates-qutrit/#skq.gates.qutrit.base.QutritGate.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert Qutrit gate to a Qiskit Gate object. Qiskit only supports qubit gates, so we convert the qutrit gate to a qubit gate first. :return: Qiskit UnitaryGate object</p> Source code in <code>src/skq/gates/qutrit/base.py</code> <pre><code>def to_qiskit(self) -&gt; qiskit.circuit.library.UnitaryGate:\n    \"\"\"\n    Convert Qutrit gate to a Qiskit Gate object.\n    Qiskit only supports qubit gates, so we convert the qutrit gate to a qubit gate first.\n    :return: Qiskit UnitaryGate object\n    \"\"\"\n    qubit_gate = self.qutrit_to_qubit()\n    return qubit_gate.to_qiskit()\n</code></pre>"},{"location":"api/gates-qutrit/#single-qutrit-gates","title":"Single-Qutrit Gates","text":""},{"location":"api/gates-qutrit/#identity-gate-qutriti","title":"Identity Gate (QutritI)","text":"<p>The Identity gate leaves the qutrit state unchanged.</p> <p>Matrix Representation:</p> \\[ \\text{QutritI} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.single.QutritI","title":"<code>skq.gates.qutrit.single.QutritI</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>Identity gate for a qutrit. [[1, 0, 0][0, 1, 0] [0, 0, 1]]</p> Source code in <code>src/skq/gates/qutrit/single.py</code> <pre><code>class QutritI(QutritGate):\n    \"\"\"\n    Identity gate for a qutrit.\n    [[1, 0, 0]\n    [0, 1, 0]\n    [0, 0, 1]]\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, np.eye(3))\n</code></pre>"},{"location":"api/gates-qutrit/#x-gate-qutritx","title":"X Gate (QutritX)","text":"<p>The X gate for a qutrit performs a cyclic permutation of the basis states: |0\u27e9 \u2192 |1\u27e9 \u2192 |2\u27e9 \u2192 |0\u27e9.</p> <p>Matrix Representation:</p> \\[ \\text{QutritX} = \\begin{pmatrix} 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.single.QutritX","title":"<code>skq.gates.qutrit.single.QutritX</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>X gate for a qutrit. |0&gt; -&gt; |1&gt; |1&gt; -&gt; |2&gt; |2&gt; -&gt; |0&gt;</p> Source code in <code>src/skq/gates/qutrit/single.py</code> <pre><code>class QutritX(QutritGate):\n    \"\"\"\n    X gate for a qutrit.\n    |0&gt; -&gt; |1&gt;\n    |1&gt; -&gt; |2&gt;\n    |2&gt; -&gt; |0&gt;\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, np.array([[0, 0, 1], [1, 0, 0], [0, 1, 0]]))\n</code></pre>"},{"location":"api/gates-qutrit/#y-gate-qutrity","title":"Y Gate (QutritY)","text":"<p>The Y gate for a qutrit performs a cyclic permutation with phase: |0\u27e9 \u2192 -i|1\u27e9 \u2192 -i|2\u27e9 \u2192 -i|0\u27e9.</p> <p>Matrix Representation:</p> \\[ \\text{QutritY} = \\begin{pmatrix} 0 &amp; 0 &amp; -i \\\\ -i &amp; 0 &amp; 0 \\\\ 0 &amp; -i &amp; 0 \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.single.QutritY","title":"<code>skq.gates.qutrit.single.QutritY</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>Y gate for a qutrit. |0&gt; -&gt; -i|1&gt; |1&gt; -&gt; -i|2&gt; |2&gt; -&gt; -i|0&gt;</p> Source code in <code>src/skq/gates/qutrit/single.py</code> <pre><code>class QutritY(QutritGate):\n    \"\"\"\n    Y gate for a qutrit.\n    |0&gt; -&gt; -i|1&gt;\n    |1&gt; -&gt; -i|2&gt;\n    |2&gt; -&gt; -i|0&gt;\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, np.array([[0, 0, -1j], [-1j, 0, 0], [0, -1j, 0]]))\n</code></pre>"},{"location":"api/gates-qutrit/#z-gate-qutritz","title":"Z Gate (QutritZ)","text":"<p>The Z gate for a qutrit applies different phases to each basis state.</p> <p>Matrix Representation:</p> \\[ \\text{QutritZ} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; e^{2\\pi i/3} &amp; 0 \\\\ 0 &amp; 0 &amp; e^{-2\\pi i/3} \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.single.QutritZ","title":"<code>skq.gates.qutrit.single.QutritZ</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>Z gate for a qutrit. |0&gt; -&gt; |0&gt; |1&gt; -&gt; exp(2pii/3)|1&gt; |2&gt; -&gt; exp(-2pii/3)|2&gt;</p> Source code in <code>src/skq/gates/qutrit/single.py</code> <pre><code>class QutritZ(QutritGate):\n    \"\"\"\n    Z gate for a qutrit.\n    |0&gt; -&gt; |0&gt;\n    |1&gt; -&gt; exp(2*pi*i/3)|1&gt;\n    |2&gt; -&gt; exp(-2*pi*i/3)|2&gt;\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, np.array([[1, 0, 0], [0, np.exp(2 * np.pi * 1j / 3), 0], [0, 0, np.exp(-2 * np.pi * 1j / 3)]]))\n</code></pre>"},{"location":"api/gates-qutrit/#hadamard-gate-qutrith","title":"Hadamard Gate (QutritH)","text":"<p>The Hadamard gate for a qutrit creates a superposition of the three basis states.</p> <p>Matrix Representation:</p> \\[ \\text{QutritH} = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; e^{2\\pi i/3} &amp; e^{4\\pi i/3} \\\\ 1 &amp; e^{4\\pi i/3} &amp; e^{2\\pi i/3} \\end{pmatrix} \\] <p>Where \\(e^{2\\pi i/3}\\) is the cube root of unity.</p>"},{"location":"api/gates-qutrit/#skq.gates.qutrit.single.QutritH","title":"<code>skq.gates.qutrit.single.QutritH</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>Hadamard gate for a qutrit. |0&gt; -&gt; (|0&gt; + |1&gt; + |2&gt;)/sqrt(3) |1&gt; -&gt; (|0&gt; + e^(2\u03c0i/3)|1&gt; + e^(4\u03c0i/3)|2&gt;)/sqrt(3) |2&gt; -&gt; (|0&gt; + e^(4\u03c0i/3)|1&gt; + e^(2\u03c0i/3)|2&gt;)/sqrt(3)</p> Source code in <code>src/skq/gates/qutrit/single.py</code> <pre><code>class QutritH(QutritGate):\n    \"\"\"\n    Hadamard gate for a qutrit.\n    |0&gt; -&gt; (|0&gt; + |1&gt; + |2&gt;)/sqrt(3)\n    |1&gt; -&gt; (|0&gt; + e^(2\u03c0i/3)|1&gt; + e^(4\u03c0i/3)|2&gt;)/sqrt(3)\n    |2&gt; -&gt; (|0&gt; + e^(4\u03c0i/3)|1&gt; + e^(2\u03c0i/3)|2&gt;)/sqrt(3)\n    \"\"\"\n\n    def __new__(cls):\n        omega = np.exp(2j * np.pi / 3)\n        return super().__new__(cls, np.array([[1, 1, 1], [1, omega, omega**2], [1, omega**2, omega]]) / np.sqrt(3))\n</code></pre>"},{"location":"api/gates-qutrit/#t-gate-qutritt","title":"T Gate (QutritT)","text":"<p>The T gate for a qutrit applies smaller phase shifts than the Z gate.</p> <p>Matrix Representation:</p> \\[ \\text{QutritT} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; e^{2\\pi i/9} &amp; 0 \\\\ 0 &amp; 0 &amp; e^{-2\\pi i/9} \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.single.QutritT","title":"<code>skq.gates.qutrit.single.QutritT</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>T gate for a qutrit. |0&gt; -&gt; |0&gt; |1&gt; -&gt; exp(2pii/9)|1&gt; |2&gt; -&gt; exp(-2pii/9)|2&gt;</p> Source code in <code>src/skq/gates/qutrit/single.py</code> <pre><code>class QutritT(QutritGate):\n    \"\"\"\n    T gate for a qutrit.\n    |0&gt; -&gt; |0&gt;\n    |1&gt; -&gt; exp(2*pi*i/9)|1&gt;\n    |2&gt; -&gt; exp(-2*pi*i/9)|2&gt;\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, np.array([[1, 0, 0], [0, np.exp(2 * np.pi * 1j / 9), 0], [0, 0, np.exp(-2 * np.pi * 1j / 9)]]))\n</code></pre>"},{"location":"api/gates-qutrit/#r-gate-qutritr","title":"R Gate (QutritR)","text":"<p>The R gate for a qutrit is a non-Clifford gate that applies a phase flip to the |2\u27e9 state.</p> <p>Matrix Representation:</p> \\[ \\text{QutritR} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; -1 \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.single.QutritR","title":"<code>skq.gates.qutrit.single.QutritR</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>R gate for a qutrit (non-Clifford gate).</p> Source code in <code>src/skq/gates/qutrit/single.py</code> <pre><code>class QutritR(QutritGate):\n    \"\"\"R gate for a qutrit (non-Clifford gate).\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, np.array([[1, 0, 0], [0, 1, 0], [0, 0, -1]]))\n</code></pre>"},{"location":"api/gates-qutrit/#phase-gate-qutritphase","title":"Phase Gate (QutritPhase)","text":"<p>The general Phase gate for qutrits applies arbitrary phase shifts to each basis state.</p> <p>Matrix Representation:</p> \\[ \\text{QutritPhase}(\\phi_0,\\phi_1,\\phi_2) = \\begin{pmatrix} e^{i\\phi_0} &amp; 0 &amp; 0 \\\\ 0 &amp; e^{i\\phi_1} &amp; 0 \\\\ 0 &amp; 0 &amp; e^{i\\phi_2} \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.single.QutritPhase","title":"<code>skq.gates.qutrit.single.QutritPhase</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>General phase gate for qutrits. Applies phase shifts to the qutrit basis states.</p> Source code in <code>src/skq/gates/qutrit/single.py</code> <pre><code>class QutritPhase(QutritGate):\n    \"\"\"\n    General phase gate for qutrits.\n    Applies phase shifts to the qutrit basis states.\n    \"\"\"\n\n    def __new__(cls, phi_0: float, phi_1: float, phi_2: float):\n        return super().__new__(cls, np.array([[np.exp(1j * phi_0), 0, 0], [0, np.exp(1j * phi_1), 0], [0, 0, np.exp(1j * phi_2)]]))\n</code></pre>"},{"location":"api/gates-qutrit/#s-gate-qutrits","title":"S Gate (QutritS)","text":"<p>The S gate for qutrits is a special case of the Phase gate.</p> <p>Matrix Representation:</p> \\[ \\text{QutritS} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; e^{2\\pi i/3} &amp; 0 \\\\ 0 &amp; 0 &amp; e^{4\\pi i/3} \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.single.QutritS","title":"<code>skq.gates.qutrit.single.QutritS</code>","text":"<p>               Bases: <code>QutritPhase</code></p> <p>S gate for qutrits. |0&gt; -&gt; |0&gt; |1&gt; -&gt; exp(2pii/3)|1&gt; |2&gt; -&gt; exp(4pii/3)|2&gt;</p> Source code in <code>src/skq/gates/qutrit/single.py</code> <pre><code>class QutritS(QutritPhase):\n    \"\"\"\n    S gate for qutrits.\n    |0&gt; -&gt; |0&gt;\n    |1&gt; -&gt; exp(2*pi*i/3)|1&gt;\n    |2&gt; -&gt; exp(4*pi*i/3)|2&gt;\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, phi_0=0, phi_1=2 * np.pi / 3, phi_2=4 * np.pi / 3)\n</code></pre>"},{"location":"api/gates-qutrit/#multi-qutrit-gates","title":"Multi-Qutrit Gates","text":""},{"location":"api/gates-qutrit/#multi-qutrit-identity-qutritmi","title":"Multi-Qutrit Identity (QutritMI)","text":"<p>The Identity gate for multiple qutrits.</p> <p>Matrix Representation (for 1 qutrit):</p> \\[ \\text{QutritMI} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.multi.QutritMI","title":"<code>skq.gates.qutrit.multi.QutritMI</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>Multi-qutrit Identity gate. :param num_qutrits: Number of qutrits in the gate.</p> Source code in <code>src/skq/gates/qutrit/multi.py</code> <pre><code>class QutritMI(QutritGate):\n    \"\"\"\n    Multi-qutrit Identity gate.\n    :param num_qutrits: Number of qutrits in the gate.\n    \"\"\"\n\n    def __new__(cls, num_qutrits: int):\n        assert num_qutrits &gt;= 1, \"Number of qutrits must be at least 1.\"\n        return super().__new__(cls, np.eye(3**num_qutrits))\n</code></pre>"},{"location":"api/gates-qutrit/#controlled-x-type-a-qutritcxa","title":"Controlled-X Type A (QutritCXA)","text":"<p>The CNOT gate for qutrits with control on |1\u27e9. This gate performs a cyclic permutation on the target qutrit if the control qutrit is in state |1\u27e9.</p> <p>Matrix Representation (9\u00d79 matrix):</p> \\[ \\text{QutritCXA} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.multi.QutritCXA","title":"<code>skq.gates.qutrit.multi.QutritCXA</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>CNOT gate for qutrits. More information on Qutrit CNOT: https://www.iosrjournals.org/iosr-jap/papers/Vol10-issue6/Version-2/D1006021619.pdf Control on |1&gt;</p> Source code in <code>src/skq/gates/qutrit/multi.py</code> <pre><code>class QutritCXA(QutritGate):\n    \"\"\"\n    CNOT gate for qutrits.\n    More information on Qutrit CNOT: https://www.iosrjournals.org/iosr-jap/papers/Vol10-issue6/Version-2/D1006021619.pdf\n    Control on |1&gt;\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(\n            cls, np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0]])\n        )\n</code></pre>"},{"location":"api/gates-qutrit/#controlled-x-type-b-qutritcxb","title":"Controlled-X Type B (QutritCXB)","text":"<p>The CNOT gate for qutrits with control on |2\u27e9. This gate performs a cyclic permutation on the target qutrit if the control qutrit is in state |2\u27e9.</p> <p>Matrix Representation (9\u00d79 matrix):</p> \\[ \\text{QutritCXB} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.multi.QutritCXB","title":"<code>skq.gates.qutrit.multi.QutritCXB</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>CNOT gate for qutrits. More information on Qutrit CNOT: https://www.iosrjournals.org/iosr-jap/papers/Vol10-issue6/Version-2/D1006021619.pdf Control on |2&gt;</p> Source code in <code>src/skq/gates/qutrit/multi.py</code> <pre><code>class QutritCXB(QutritGate):\n    \"\"\"\n    CNOT gate for qutrits.\n    More information on Qutrit CNOT: https://www.iosrjournals.org/iosr-jap/papers/Vol10-issue6/Version-2/D1006021619.pdf\n    Control on |2&gt;\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(\n            cls, np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0]])\n        )\n</code></pre>"},{"location":"api/gates-qutrit/#controlled-x-type-c-qutritcxc","title":"Controlled-X Type C (QutritCXC)","text":"<p>The CNOT gate for qutrits with control on |0\u27e9. This gate performs a cyclic permutation on the target qutrit if the control qutrit is in state |0\u27e9.</p> <p>Matrix Representation (9\u00d79 matrix):</p> \\[ \\text{QutritCXC} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.multi.QutritCXC","title":"<code>skq.gates.qutrit.multi.QutritCXC</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>CNOT gate for qutrits. More information on Qutrit CNOT: https://www.iosrjournals.org/iosr-jap/papers/Vol10-issue6/Version-2/D1006021619.pdf Control on |0&gt;</p> Source code in <code>src/skq/gates/qutrit/multi.py</code> <pre><code>class QutritCXC(QutritGate):\n    \"\"\"\n    CNOT gate for qutrits.\n    More information on Qutrit CNOT: https://www.iosrjournals.org/iosr-jap/papers/Vol10-issue6/Version-2/D1006021619.pdf\n    Control on |0&gt;\n    \"\"\"\n\n    def __new__(cls):\n        return super().__new__(\n            cls, np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0]])\n        )\n</code></pre>"},{"location":"api/gates-qutrit/#swap-gate-qutritswap","title":"SWAP Gate (QutritSWAP)","text":"<p>The SWAP gate for qutrits exchanges the states of two qutrits.</p> <p>Matrix Representation (9\u00d79 matrix):</p> \\[ \\text{QutritSWAP} = \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\end{pmatrix} \\]"},{"location":"api/gates-qutrit/#skq.gates.qutrit.multi.QutritSWAP","title":"<code>skq.gates.qutrit.multi.QutritSWAP</code>","text":"<p>               Bases: <code>QutritGate</code></p> <p>SWAP gate for qutrits. |01&gt; -&gt; |10&gt; |10&gt; -&gt; |01&gt;</p> Source code in <code>src/skq/gates/qutrit/multi.py</code> <pre><code>class QutritSWAP(QutritGate):\n    \"\"\"\n    SWAP gate for qutrits.\n    |01&gt; -&gt; |10&gt;\n    |10&gt; -&gt; |01&gt;\n    \"\"\"\n\n    def __new__(cls):\n        swap_matrix = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1]])\n        return super().__new__(cls, swap_matrix)\n</code></pre>"},{"location":"api/quantum-info/","title":"Quantum Information API Reference","text":"<p>This page documents the classes and functions available in the <code>skq.quantum_info</code> module. This module provides tools for working with quantum states, density matrices, quantum channels, Hamiltonians, and other quantum information concepts.</p>"},{"location":"api/quantum-info/#state-representations","title":"State Representations","text":""},{"location":"api/quantum-info/#statevector","title":"Statevector","text":"<p>The <code>Statevector</code> class provides a representation for pure quantum states.</p> <pre><code>from skq.quantum_info import Statevector\n\n# Create a state vector\nstate = Statevector([1/np.sqrt(2), 1/np.sqrt(2)])\nprint(state.num_qubits)  # 1\nprint(state.is_normalized())  # True\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector","title":"<code>skq.quantum_info.Statevector</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>Statevector representation for a quantum (qubit) state. NOTE: Input is assumed to be in big-endian format. Little-endian -&gt; Least significant qubit (LSB) is on the right. Like |q1 q0&gt; where q0 is the LSB. Big-endian -&gt; Least significant qubit (LSB) is on the left. Like |q0 q1&gt; where q0 is the LSB.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class Statevector(np.ndarray):\n    \"\"\"\n    Statevector representation for a quantum (qubit) state.\n    NOTE: Input is assumed to be in big-endian format.\n    Little-endian -&gt; Least significant qubit (LSB) is on the right. Like |q1 q0&gt; where q0 is the LSB.\n    Big-endian -&gt; Least significant qubit (LSB) is on the left. Like |q0 q1&gt; where q0 is the LSB.\n    \"\"\"\n\n    def __new__(cls, input_array):\n        arr = np.asarray(input_array, dtype=complex)\n        obj = arr.view(cls)\n        assert obj.is_1d(), \"State vector must be 1D.\"\n        assert obj.is_normalized(), \"State vector must be normalized.\"\n        assert obj.is_power_of_two_len(), \"State vector length must be a least length 2 and a power of 2.\"\n        return obj\n\n    @property\n    def num_qubits(self) -&gt; int:\n        \"\"\"Number of qubits in the state vector.\"\"\"\n        return int(np.log2(len(self)))\n\n    def is_1d(self) -&gt; bool:\n        \"\"\"State vector is 1D.\"\"\"\n        return self.ndim == 1\n\n    def is_normalized(self) -&gt; bool:\n        \"\"\"State vector is normalized: ||\u03c8|| = 1.\"\"\"\n        return np.isclose(np.linalg.norm(self), 1)\n\n    def is_power_of_two_len(self) -&gt; bool:\n        \"\"\"Check if a number is a power of two\"\"\"\n        n = len(self)\n        return n &gt;= 2 and (n &amp; (n - 1)) == 0\n\n    def is_multi_qubit(self) -&gt; bool:\n        \"\"\"State vector represents a multi-qubit state.\"\"\"\n        return self.num_qubits &gt; 1\n\n    def is_indistinguishable(self, other: \"Statevector\") -&gt; bool:\n        \"\"\"Two state vectors are indistinguishable if their density matrices are the same.\"\"\"\n        return np.allclose(self.density_matrix(), other.density_matrix())\n\n    def magnitude(self) -&gt; float:\n        \"\"\"Magnitude (or norm) of the state vector. sqrt(&lt;\u03c8|\u03c8&gt;)\"\"\"\n        np.linalg.norm(self)\n\n    def expectation(self, operator: np.array) -&gt; float:\n        \"\"\"\n        Expectation value of an observable with respect to the quantum state.\n        computes &lt;\u03c8|O|\u03c8&gt;\n        :param operator: The observable (Hermitian matrix) as a 2D numpy array.\n        :return: Expectation value.\n        \"\"\"\n        assert len(operator.shape) == 2, \"The operator must be a 2D matrix.\"\n        assert np.allclose(operator, operator.T.conj()), \"The operator must be Hermitian.\"\n        return float(np.real(self.conjugate_transpose() @ operator @ self))\n\n    def density_matrix(self) -&gt; DensityMatrix:\n        \"\"\"Return the density matrix representation of the state vector.\"\"\"\n        return DensityMatrix(np.outer(self, self.conj()))\n\n    def probabilities(self) -&gt; np.ndarray:\n        \"\"\"Probabilities of all possible states.\"\"\"\n        return np.abs(self) ** 2\n\n    def measure_index(self) -&gt; int:\n        \"\"\"\n        Simulate a measurement of the state and get a sampled index.\n        :return: Index of the measured state.\n        For example:\n        |0&gt; -&gt; 0\n        |00&gt; -&gt; 0\n        |11&gt; -&gt; 3\n        \"\"\"\n        return np.random.choice(len(self), p=self.probabilities())\n\n    def measure_bitstring(self) -&gt; str:\n        \"\"\"\n        Simulate a measurement of the state vector and get a bitstring representing the sample.\n        :return: Bitstring representation of the measured state.\n        For example:\n        |0&gt; -&gt; \"0\"\n        |00&gt; -&gt; \"00\"\n        |11&gt; -&gt; \"11\"\n        \"\"\"\n        return bin(self.measure_index())[2:].zfill(self.num_qubits)\n\n    def reverse(self) -&gt; \"Statevector\":\n        \"\"\"Reverse the order of the state vector to account for endianness.\n        For example Qiskit uses little endian convention.\n        Little-endian -&gt; Least significant qubit (LSB) is on the right. Like |q1 q0&gt; where q0 is the LSB.\n        Big-endian -&gt; Least significant qubit (LSB) is on the left. Like |q0 q1&gt; where q0 is the LSB.\n        \"\"\"\n        return Statevector(self[::-1])\n\n    def bloch_vector(self) -&gt; np.ndarray:\n        \"\"\"Bloch vector representation of the quantum state.\"\"\"\n        return self.density_matrix().bloch_vector()\n\n    def conjugate_transpose(self) -&gt; np.ndarray:\n        \"\"\"Conjugate transpose (Hermitian adjoint) of the state vector.\"\"\"\n        return self.T.conj()\n\n    def orthonormal_basis(self) -&gt; np.ndarray:\n        \"\"\"\n        Orthonormal basis using the Gram-Schmidt process.\n        :return: 2D array representing the orthonormal basis.\n        \"\"\"\n        return np.array([self / np.linalg.norm(self)]).T\n\n    def schmidt_decomposition(self) -&gt; tuple[np.array, np.array, np.array]:\n        \"\"\"\n        Perform Schmidt decomposition on a quantum state.\n        :return: Tuple of Schmidt coefficients, Basis A and Basis B\n        \"\"\"\n        # Infer dimensions\n        N = len(self)\n        dim_A = int(np.sqrt(N))\n        dim_B = N // dim_A\n\n        # Singular Value Decomposition\n        state_matrix = self.reshape(dim_A, dim_B)\n        U, S, Vh = svd(state_matrix)\n\n        # Coefficients (S), Basis A (U) and Basis B (Vh^dagger)\n        return S, U, Vh.conj().T\n\n    def to_qiskit(self) -&gt; qiskit.quantum_info.Statevector:\n        \"\"\"\n        Convert the state vector to a Qiskit QuantumCircuit object.\n        Qiskit uses little-endian convention.\n        :return: Qiskit StateVector object\n        \"\"\"\n        return qiskit.quantum_info.Statevector(self.reverse())\n\n    @staticmethod\n    def from_qiskit(statevector: qiskit.quantum_info.Statevector) -&gt; \"Statevector\":\n        \"\"\"\n        Convert a Qiskit StateVector object to a scikit-q StateVector.\n        Qiskit uses little-endian convention.\n        :param statevector: Qiskit StateVector object\n        :return: scikit-q StateVector object\n        \"\"\"\n        return Statevector(statevector.data).reverse()\n\n    def to_pyquil(self):\n        \"\"\"\n        Convert the state vector to a PyQuil object.\n        PyQuil uses little-endian convention.\n        :return: PyQuil object\n        \"\"\"\n        raise NotImplementedError(\"Conversion to PyQuil is not implemented.\")\n\n    @staticmethod\n    def from_pyquil(statevector) -&gt; \"Statevector\":\n        \"\"\"\n        Convert a PyQuil object to a scikit-q StateVector object.\n        PyQuil uses little-endian convention.\n        :return: scikit-q StateVector object\n        \"\"\"\n        raise NotImplementedError(\"Conversion from PyQuil is not implemented.\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.num_qubits","title":"<code>num_qubits</code>  <code>property</code>","text":"<p>Number of qubits in the state vector.</p>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.bloch_vector","title":"<code>bloch_vector()</code>","text":"<p>Bloch vector representation of the quantum state.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def bloch_vector(self) -&gt; np.ndarray:\n    \"\"\"Bloch vector representation of the quantum state.\"\"\"\n    return self.density_matrix().bloch_vector()\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.conjugate_transpose","title":"<code>conjugate_transpose()</code>","text":"<p>Conjugate transpose (Hermitian adjoint) of the state vector.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def conjugate_transpose(self) -&gt; np.ndarray:\n    \"\"\"Conjugate transpose (Hermitian adjoint) of the state vector.\"\"\"\n    return self.T.conj()\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.density_matrix","title":"<code>density_matrix()</code>","text":"<p>Return the density matrix representation of the state vector.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def density_matrix(self) -&gt; DensityMatrix:\n    \"\"\"Return the density matrix representation of the state vector.\"\"\"\n    return DensityMatrix(np.outer(self, self.conj()))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.expectation","title":"<code>expectation(operator)</code>","text":"<p>Expectation value of an observable with respect to the quantum state. computes &lt;\u03c8|O|\u03c8&gt; :param operator: The observable (Hermitian matrix) as a 2D numpy array. :return: Expectation value.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def expectation(self, operator: np.array) -&gt; float:\n    \"\"\"\n    Expectation value of an observable with respect to the quantum state.\n    computes &lt;\u03c8|O|\u03c8&gt;\n    :param operator: The observable (Hermitian matrix) as a 2D numpy array.\n    :return: Expectation value.\n    \"\"\"\n    assert len(operator.shape) == 2, \"The operator must be a 2D matrix.\"\n    assert np.allclose(operator, operator.T.conj()), \"The operator must be Hermitian.\"\n    return float(np.real(self.conjugate_transpose() @ operator @ self))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.from_pyquil","title":"<code>from_pyquil(statevector)</code>  <code>staticmethod</code>","text":"<p>Convert a PyQuil object to a scikit-q StateVector object. PyQuil uses little-endian convention. :return: scikit-q StateVector object</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>@staticmethod\ndef from_pyquil(statevector) -&gt; \"Statevector\":\n    \"\"\"\n    Convert a PyQuil object to a scikit-q StateVector object.\n    PyQuil uses little-endian convention.\n    :return: scikit-q StateVector object\n    \"\"\"\n    raise NotImplementedError(\"Conversion from PyQuil is not implemented.\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.from_qiskit","title":"<code>from_qiskit(statevector)</code>  <code>staticmethod</code>","text":"<p>Convert a Qiskit StateVector object to a scikit-q StateVector. Qiskit uses little-endian convention. :param statevector: Qiskit StateVector object :return: scikit-q StateVector object</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>@staticmethod\ndef from_qiskit(statevector: qiskit.quantum_info.Statevector) -&gt; \"Statevector\":\n    \"\"\"\n    Convert a Qiskit StateVector object to a scikit-q StateVector.\n    Qiskit uses little-endian convention.\n    :param statevector: Qiskit StateVector object\n    :return: scikit-q StateVector object\n    \"\"\"\n    return Statevector(statevector.data).reverse()\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.is_1d","title":"<code>is_1d()</code>","text":"<p>State vector is 1D.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def is_1d(self) -&gt; bool:\n    \"\"\"State vector is 1D.\"\"\"\n    return self.ndim == 1\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.is_indistinguishable","title":"<code>is_indistinguishable(other)</code>","text":"<p>Two state vectors are indistinguishable if their density matrices are the same.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def is_indistinguishable(self, other: \"Statevector\") -&gt; bool:\n    \"\"\"Two state vectors are indistinguishable if their density matrices are the same.\"\"\"\n    return np.allclose(self.density_matrix(), other.density_matrix())\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.is_multi_qubit","title":"<code>is_multi_qubit()</code>","text":"<p>State vector represents a multi-qubit state.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def is_multi_qubit(self) -&gt; bool:\n    \"\"\"State vector represents a multi-qubit state.\"\"\"\n    return self.num_qubits &gt; 1\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.is_normalized","title":"<code>is_normalized()</code>","text":"<p>State vector is normalized: ||\u03c8|| = 1.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def is_normalized(self) -&gt; bool:\n    \"\"\"State vector is normalized: ||\u03c8|| = 1.\"\"\"\n    return np.isclose(np.linalg.norm(self), 1)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.is_power_of_two_len","title":"<code>is_power_of_two_len()</code>","text":"<p>Check if a number is a power of two</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def is_power_of_two_len(self) -&gt; bool:\n    \"\"\"Check if a number is a power of two\"\"\"\n    n = len(self)\n    return n &gt;= 2 and (n &amp; (n - 1)) == 0\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.magnitude","title":"<code>magnitude()</code>","text":"<p>Magnitude (or norm) of the state vector. sqrt(&lt;\u03c8|\u03c8&gt;)</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def magnitude(self) -&gt; float:\n    \"\"\"Magnitude (or norm) of the state vector. sqrt(&lt;\u03c8|\u03c8&gt;)\"\"\"\n    np.linalg.norm(self)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.measure_bitstring","title":"<code>measure_bitstring()</code>","text":"<p>Simulate a measurement of the state vector and get a bitstring representing the sample. :return: Bitstring representation of the measured state. For example: |0&gt; -&gt; \"0\" |00&gt; -&gt; \"00\" |11&gt; -&gt; \"11\"</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def measure_bitstring(self) -&gt; str:\n    \"\"\"\n    Simulate a measurement of the state vector and get a bitstring representing the sample.\n    :return: Bitstring representation of the measured state.\n    For example:\n    |0&gt; -&gt; \"0\"\n    |00&gt; -&gt; \"00\"\n    |11&gt; -&gt; \"11\"\n    \"\"\"\n    return bin(self.measure_index())[2:].zfill(self.num_qubits)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.measure_index","title":"<code>measure_index()</code>","text":"<p>Simulate a measurement of the state and get a sampled index. :return: Index of the measured state. For example: |0&gt; -&gt; 0 |00&gt; -&gt; 0 |11&gt; -&gt; 3</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def measure_index(self) -&gt; int:\n    \"\"\"\n    Simulate a measurement of the state and get a sampled index.\n    :return: Index of the measured state.\n    For example:\n    |0&gt; -&gt; 0\n    |00&gt; -&gt; 0\n    |11&gt; -&gt; 3\n    \"\"\"\n    return np.random.choice(len(self), p=self.probabilities())\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.orthonormal_basis","title":"<code>orthonormal_basis()</code>","text":"<p>Orthonormal basis using the Gram-Schmidt process. :return: 2D array representing the orthonormal basis.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def orthonormal_basis(self) -&gt; np.ndarray:\n    \"\"\"\n    Orthonormal basis using the Gram-Schmidt process.\n    :return: 2D array representing the orthonormal basis.\n    \"\"\"\n    return np.array([self / np.linalg.norm(self)]).T\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.probabilities","title":"<code>probabilities()</code>","text":"<p>Probabilities of all possible states.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def probabilities(self) -&gt; np.ndarray:\n    \"\"\"Probabilities of all possible states.\"\"\"\n    return np.abs(self) ** 2\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.reverse","title":"<code>reverse()</code>","text":"<p>Reverse the order of the state vector to account for endianness. For example Qiskit uses little endian convention. Little-endian -&gt; Least significant qubit (LSB) is on the right. Like |q1 q0&gt; where q0 is the LSB. Big-endian -&gt; Least significant qubit (LSB) is on the left. Like |q0 q1&gt; where q0 is the LSB.</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def reverse(self) -&gt; \"Statevector\":\n    \"\"\"Reverse the order of the state vector to account for endianness.\n    For example Qiskit uses little endian convention.\n    Little-endian -&gt; Least significant qubit (LSB) is on the right. Like |q1 q0&gt; where q0 is the LSB.\n    Big-endian -&gt; Least significant qubit (LSB) is on the left. Like |q0 q1&gt; where q0 is the LSB.\n    \"\"\"\n    return Statevector(self[::-1])\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.schmidt_decomposition","title":"<code>schmidt_decomposition()</code>","text":"<p>Perform Schmidt decomposition on a quantum state. :return: Tuple of Schmidt coefficients, Basis A and Basis B</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def schmidt_decomposition(self) -&gt; tuple[np.array, np.array, np.array]:\n    \"\"\"\n    Perform Schmidt decomposition on a quantum state.\n    :return: Tuple of Schmidt coefficients, Basis A and Basis B\n    \"\"\"\n    # Infer dimensions\n    N = len(self)\n    dim_A = int(np.sqrt(N))\n    dim_B = N // dim_A\n\n    # Singular Value Decomposition\n    state_matrix = self.reshape(dim_A, dim_B)\n    U, S, Vh = svd(state_matrix)\n\n    # Coefficients (S), Basis A (U) and Basis B (Vh^dagger)\n    return S, U, Vh.conj().T\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.to_pyquil","title":"<code>to_pyquil()</code>","text":"<p>Convert the state vector to a PyQuil object. PyQuil uses little-endian convention. :return: PyQuil object</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def to_pyquil(self):\n    \"\"\"\n    Convert the state vector to a PyQuil object.\n    PyQuil uses little-endian convention.\n    :return: PyQuil object\n    \"\"\"\n    raise NotImplementedError(\"Conversion to PyQuil is not implemented.\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Statevector.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert the state vector to a Qiskit QuantumCircuit object. Qiskit uses little-endian convention. :return: Qiskit StateVector object</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>def to_qiskit(self) -&gt; qiskit.quantum_info.Statevector:\n    \"\"\"\n    Convert the state vector to a Qiskit QuantumCircuit object.\n    Qiskit uses little-endian convention.\n    :return: Qiskit StateVector object\n    \"\"\"\n    return qiskit.quantum_info.Statevector(self.reverse())\n</code></pre>"},{"location":"api/quantum-info/#predefined-states","title":"Predefined States","text":"<p>SKQ provides several predefined quantum states:</p>"},{"location":"api/quantum-info/#skq.quantum_info.ZeroState","title":"<code>skq.quantum_info.ZeroState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>Zero state |0...0&gt;</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class ZeroState(Statevector):\n    \"\"\"Zero state |0...0&gt;\"\"\"\n\n    def __new__(cls, num_qubits: int):\n        return super().__new__(cls, [1] + [0] * (2**num_qubits - 1))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.OneState","title":"<code>skq.quantum_info.OneState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>One state |1...1&gt;</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class OneState(Statevector):\n    \"\"\"One state |1...1&gt;\"\"\"\n\n    def __new__(cls, num_qubits: int):\n        return super().__new__(cls, [0] * (2**num_qubits - 1) + [1])\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.PlusState","title":"<code>skq.quantum_info.PlusState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>Single Qubit |+&gt; superposition state</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class PlusState(Statevector):\n    \"\"\"Single Qubit |+&gt; superposition state\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [1, 1] / np.sqrt(2))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.MinusState","title":"<code>skq.quantum_info.MinusState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>Single Qubit |-&gt; superposition state</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class MinusState(Statevector):\n    \"\"\"Single Qubit |-&gt; superposition state\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [1, -1] / np.sqrt(2))\n</code></pre>"},{"location":"api/quantum-info/#bell-states","title":"Bell States","text":""},{"location":"api/quantum-info/#skq.quantum_info.PhiPlusState","title":"<code>skq.quantum_info.PhiPlusState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>Bell state |\u03a6+&gt;</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class PhiPlusState(Statevector):\n    \"\"\"Bell state |\u03a6+&gt;\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [1, 0, 0, 1] / np.sqrt(2))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.PhiMinusState","title":"<code>skq.quantum_info.PhiMinusState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>Bell state |\u03a6-&gt;</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class PhiMinusState(Statevector):\n    \"\"\"Bell state |\u03a6-&gt;\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [1, 0, 0, -1] / np.sqrt(2))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.PsiPlusState","title":"<code>skq.quantum_info.PsiPlusState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>Bell state |\u03a8+&gt;</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class PsiPlusState(Statevector):\n    \"\"\"Bell state |\u03a8+&gt;\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [0, 1, 1, 0] / np.sqrt(2))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.PsiMinusState","title":"<code>skq.quantum_info.PsiMinusState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>Bell state |\u03a8-&gt;</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class PsiMinusState(Statevector):\n    \"\"\"Bell state |\u03a8-&gt;\"\"\"\n\n    def __new__(cls):\n        return super().__new__(cls, [0, 1, -1, 0] / np.sqrt(2))\n</code></pre>"},{"location":"api/quantum-info/#multi-qubit-states","title":"Multi-qubit States","text":""},{"location":"api/quantum-info/#skq.quantum_info.GHZState","title":"<code>skq.quantum_info.GHZState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>GHZ state |0...0&gt; + |1...1&gt;</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class GHZState(Statevector):\n    \"\"\"GHZ state |0...0&gt; + |1...1&gt;\"\"\"\n\n    def __new__(cls, num_qubits: int):\n        assert num_qubits &gt;= 3, \"GHZ state requires at least 3 qubits.\"\n        state = np.zeros(2**num_qubits)\n        state[0] = 1 / np.sqrt(2)\n        state[-1] = 1 / np.sqrt(2)\n        return super().__new__(cls, state)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.WState","title":"<code>skq.quantum_info.WState</code>","text":"<p>               Bases: <code>Statevector</code></p> <p>W state |001&gt; + |010&gt; + |100&gt;</p> Source code in <code>src/skq/quantum_info/state.py</code> <pre><code>class WState(Statevector):\n    \"\"\"W state |001&gt; + |010&gt; + |100&gt;\"\"\"\n\n    def __new__(cls, num_qubits: int):\n        assert num_qubits &gt;= 3, \"W state requires at least 3 qubits.\"\n        state = np.zeros(2**num_qubits)\n        for i in range(num_qubits):\n            state[2**i] = 1 / np.sqrt(num_qubits)\n        return super().__new__(cls, state)\n</code></pre>"},{"location":"api/quantum-info/#density-matrices","title":"Density Matrices","text":"<p>Density matrices represent both pure and mixed quantum states.</p> <pre><code>from skq.quantum_info import DensityMatrix\n\n# Create a density matrix\nrho = DensityMatrix(np.array([[0.5, 0], [0, 0.5]]))\nprint(rho.is_pure())  # False\nprint(rho.is_mixed())  # True\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix","title":"<code>skq.quantum_info.DensityMatrix</code>","text":"<p>               Bases: <code>HermitianOperator</code></p> <p>Density matrix representation of a qubit state.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>class DensityMatrix(HermitianOperator):\n    \"\"\"Density matrix representation of a qubit state.\"\"\"\n\n    def __new__(cls, input_array):\n        obj = super().__new__(cls, input_array)\n        assert obj.is_positive_semidefinite(), \"Density matrix must be positive semidefinite (All eigenvalues &gt;= 0).\"\n        assert obj.trace_equal_to_one(), \"Density matrix must have trace equal to one. Normalize to unit trace if you want to use this matrix as a DensityMatrix.\"\n        return obj\n\n    @property\n    def num_qubits(self) -&gt; int:\n        \"\"\"Number of qubits in the density matrix.\"\"\"\n        return int(np.log2(len(self)))\n\n    def is_positive_semidefinite(self):\n        \"\"\"Matrix is positive semidefinite.\"\"\"\n        eigenvalues = np.linalg.eigvalsh(self)\n        return np.all(eigenvalues &gt;= 0)\n\n    def is_pure(self) -&gt; bool:\n        \"\"\"Check if density matrix is pure.\"\"\"\n        return np.isclose(np.trace(self @ self), 1)\n\n    def is_mixed(self) -&gt; bool:\n        \"\"\"Check if density matrix is mixed.\"\"\"\n        return not self.is_pure()\n\n    def trace_equal_to_one(self) -&gt; bool:\n        \"\"\"Trace of density matrix is equal to one.\"\"\"\n        return np.isclose(np.trace(self), 1)\n\n    def probabilities(self) -&gt; float:\n        \"\"\"Probabilities of all possible state measurements.\"\"\"\n        return np.diag(self).real\n\n    def is_multi_qubit(self) -&gt; bool:\n        \"\"\"Check if the density matrix represents a multi-qubit state.\"\"\"\n        return self.num_qubits &gt; 1\n\n    def trace_norm(self) -&gt; float:\n        \"\"\"Trace norm of the density matrix.\"\"\"\n        return np.trace(np.sqrt(self.conjugate_transpose() @ self))\n\n    def distance(self, other: \"DensityMatrix\") -&gt; float:\n        \"\"\"Trace norm distance between two density matrices.\"\"\"\n        assert isinstance(other, DensityMatrix), \"'other' argument must be a valid DensityMatrix object.\"\n        return self.trace_norm(self - other)\n\n    def bloch_vector(self) -&gt; np.ndarray:\n        \"\"\"Bloch vector of the density matrix.\"\"\"\n        if self.num_qubits &gt; 1:\n            raise NotImplementedError(\"Bloch vector is not yet implemented for multi-qubit states.\")\n\n        # Bloch vector components\n        bx = np.trace(np.dot(self, X())).real\n        by = np.trace(np.dot(self, Y())).real\n        bz = np.trace(np.dot(self, Z())).real\n        return np.array([bx, by, bz])\n\n    def kron(self, other: \"DensityMatrix\") -&gt; \"DensityMatrix\":\n        \"\"\"\n        Kronecker (tensor) product of two density matrices.\n        This can be used to create so-called \"product states\" that represent\n        the independence between two quantum systems.\n        :param other: DensityMatrix object\n        :return: Kronecker product of the two density matrices\n        \"\"\"\n        return DensityMatrix(np.kron(self, other))\n\n    def entropy(self):\n        \"\"\"von Neumann entropy.\"\"\"\n        eigenvals = self.eigenvalues()\n        # Only consider non-zero eigenvalues\n        nonzero_eigenvalues = eigenvals[eigenvals &gt; 0]\n        return -np.sum(nonzero_eigenvalues * np.log(nonzero_eigenvalues))\n\n    def internal_energy(self, hamiltonian: np.array) -&gt; float:\n        \"\"\"\n        Expected value of the Hamiltonian.\n        :param hamiltonian: Hamiltonian matrix\n        :return: Expected value of the Hamiltonian\n        \"\"\"\n        return np.trace(self @ hamiltonian)\n\n    def to_qiskit(self) -&gt; qiskit.quantum_info.DensityMatrix:\n        \"\"\"\n        Convert the density matrix to a Qiskit DensityMatrix object.\n        :return: Qiskit DensityMatrix object\n        \"\"\"\n        return qiskit.quantum_info.DensityMatrix(self)\n\n    @staticmethod\n    def from_qiskit(density_matrix: qiskit.quantum_info.DensityMatrix) -&gt; \"DensityMatrix\":\n        \"\"\"\n        Create a DensityMatrix object from a Qiskit DensityMatrix object.\n        :param density_matrix: Qiskit DensityMatrix object\n        :return: DensityMatrix object\n        \"\"\"\n        return DensityMatrix(density_matrix.data)\n\n    def to_pennylane(self, wires: list[int] | int = None) -&gt; qml.QubitDensityMatrix:\n        \"\"\"\n        Convert the density matrix to a PennyLane QubitDensityMatrix.\n        :param wires: List of wires to apply the density matrix to\n        :return: PennyLane QubitDensityMatrix object\n        \"\"\"\n        wires = wires if wires is not None else range(self.num_qubits)\n        return qml.QubitDensityMatrix(self, wires=wires)\n\n    @staticmethod\n    def from_pennylane(density_matrix: qml.QubitDensityMatrix) -&gt; \"DensityMatrix\":\n        \"\"\"\n        Convert a PennyLane QubitDensityMarix object to a scikit-q StateVector.\n        :param density_matrix: PennyLane QubitDensityMatrix object\n        :return: scikit-q StateVector object\n        \"\"\"\n        return DensityMatrix(density_matrix.data[0])\n\n    @staticmethod\n    def from_probabilities(probabilities: np.array) -&gt; \"DensityMatrix\":\n        \"\"\"\n        Create a density matrix from a list of probabilities.\n        :param probabilities: A 1D array of probabilities\n        :return: Density matrix\n        \"\"\"\n        assert np.isclose(np.sum(probabilities), 1), f\"Probabilities must sum to one. Got sum: {np.sum(probabilities)}\"\n        assert len(probabilities.shape) == 1, f\"Probabilities must be a 1D array. Got shape: {probabilities.shape}\"\n        return DensityMatrix(np.diag(probabilities))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.num_qubits","title":"<code>num_qubits</code>  <code>property</code>","text":"<p>Number of qubits in the density matrix.</p>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.bloch_vector","title":"<code>bloch_vector()</code>","text":"<p>Bloch vector of the density matrix.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def bloch_vector(self) -&gt; np.ndarray:\n    \"\"\"Bloch vector of the density matrix.\"\"\"\n    if self.num_qubits &gt; 1:\n        raise NotImplementedError(\"Bloch vector is not yet implemented for multi-qubit states.\")\n\n    # Bloch vector components\n    bx = np.trace(np.dot(self, X())).real\n    by = np.trace(np.dot(self, Y())).real\n    bz = np.trace(np.dot(self, Z())).real\n    return np.array([bx, by, bz])\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.distance","title":"<code>distance(other)</code>","text":"<p>Trace norm distance between two density matrices.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def distance(self, other: \"DensityMatrix\") -&gt; float:\n    \"\"\"Trace norm distance between two density matrices.\"\"\"\n    assert isinstance(other, DensityMatrix), \"'other' argument must be a valid DensityMatrix object.\"\n    return self.trace_norm(self - other)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.entropy","title":"<code>entropy()</code>","text":"<p>von Neumann entropy.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def entropy(self):\n    \"\"\"von Neumann entropy.\"\"\"\n    eigenvals = self.eigenvalues()\n    # Only consider non-zero eigenvalues\n    nonzero_eigenvalues = eigenvals[eigenvals &gt; 0]\n    return -np.sum(nonzero_eigenvalues * np.log(nonzero_eigenvalues))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.from_pennylane","title":"<code>from_pennylane(density_matrix)</code>  <code>staticmethod</code>","text":"<p>Convert a PennyLane QubitDensityMarix object to a scikit-q StateVector. :param density_matrix: PennyLane QubitDensityMatrix object :return: scikit-q StateVector object</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>@staticmethod\ndef from_pennylane(density_matrix: qml.QubitDensityMatrix) -&gt; \"DensityMatrix\":\n    \"\"\"\n    Convert a PennyLane QubitDensityMarix object to a scikit-q StateVector.\n    :param density_matrix: PennyLane QubitDensityMatrix object\n    :return: scikit-q StateVector object\n    \"\"\"\n    return DensityMatrix(density_matrix.data[0])\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.from_probabilities","title":"<code>from_probabilities(probabilities)</code>  <code>staticmethod</code>","text":"<p>Create a density matrix from a list of probabilities. :param probabilities: A 1D array of probabilities :return: Density matrix</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>@staticmethod\ndef from_probabilities(probabilities: np.array) -&gt; \"DensityMatrix\":\n    \"\"\"\n    Create a density matrix from a list of probabilities.\n    :param probabilities: A 1D array of probabilities\n    :return: Density matrix\n    \"\"\"\n    assert np.isclose(np.sum(probabilities), 1), f\"Probabilities must sum to one. Got sum: {np.sum(probabilities)}\"\n    assert len(probabilities.shape) == 1, f\"Probabilities must be a 1D array. Got shape: {probabilities.shape}\"\n    return DensityMatrix(np.diag(probabilities))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.from_qiskit","title":"<code>from_qiskit(density_matrix)</code>  <code>staticmethod</code>","text":"<p>Create a DensityMatrix object from a Qiskit DensityMatrix object. :param density_matrix: Qiskit DensityMatrix object :return: DensityMatrix object</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>@staticmethod\ndef from_qiskit(density_matrix: qiskit.quantum_info.DensityMatrix) -&gt; \"DensityMatrix\":\n    \"\"\"\n    Create a DensityMatrix object from a Qiskit DensityMatrix object.\n    :param density_matrix: Qiskit DensityMatrix object\n    :return: DensityMatrix object\n    \"\"\"\n    return DensityMatrix(density_matrix.data)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.internal_energy","title":"<code>internal_energy(hamiltonian)</code>","text":"<p>Expected value of the Hamiltonian. :param hamiltonian: Hamiltonian matrix :return: Expected value of the Hamiltonian</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def internal_energy(self, hamiltonian: np.array) -&gt; float:\n    \"\"\"\n    Expected value of the Hamiltonian.\n    :param hamiltonian: Hamiltonian matrix\n    :return: Expected value of the Hamiltonian\n    \"\"\"\n    return np.trace(self @ hamiltonian)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.is_mixed","title":"<code>is_mixed()</code>","text":"<p>Check if density matrix is mixed.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def is_mixed(self) -&gt; bool:\n    \"\"\"Check if density matrix is mixed.\"\"\"\n    return not self.is_pure()\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.is_multi_qubit","title":"<code>is_multi_qubit()</code>","text":"<p>Check if the density matrix represents a multi-qubit state.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def is_multi_qubit(self) -&gt; bool:\n    \"\"\"Check if the density matrix represents a multi-qubit state.\"\"\"\n    return self.num_qubits &gt; 1\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.is_positive_semidefinite","title":"<code>is_positive_semidefinite()</code>","text":"<p>Matrix is positive semidefinite.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def is_positive_semidefinite(self):\n    \"\"\"Matrix is positive semidefinite.\"\"\"\n    eigenvalues = np.linalg.eigvalsh(self)\n    return np.all(eigenvalues &gt;= 0)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.is_pure","title":"<code>is_pure()</code>","text":"<p>Check if density matrix is pure.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def is_pure(self) -&gt; bool:\n    \"\"\"Check if density matrix is pure.\"\"\"\n    return np.isclose(np.trace(self @ self), 1)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.kron","title":"<code>kron(other)</code>","text":"<p>Kronecker (tensor) product of two density matrices. This can be used to create so-called \"product states\" that represent the independence between two quantum systems. :param other: DensityMatrix object :return: Kronecker product of the two density matrices</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def kron(self, other: \"DensityMatrix\") -&gt; \"DensityMatrix\":\n    \"\"\"\n    Kronecker (tensor) product of two density matrices.\n    This can be used to create so-called \"product states\" that represent\n    the independence between two quantum systems.\n    :param other: DensityMatrix object\n    :return: Kronecker product of the two density matrices\n    \"\"\"\n    return DensityMatrix(np.kron(self, other))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.probabilities","title":"<code>probabilities()</code>","text":"<p>Probabilities of all possible state measurements.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def probabilities(self) -&gt; float:\n    \"\"\"Probabilities of all possible state measurements.\"\"\"\n    return np.diag(self).real\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.to_pennylane","title":"<code>to_pennylane(wires=None)</code>","text":"<p>Convert the density matrix to a PennyLane QubitDensityMatrix. :param wires: List of wires to apply the density matrix to :return: PennyLane QubitDensityMatrix object</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def to_pennylane(self, wires: list[int] | int = None) -&gt; qml.QubitDensityMatrix:\n    \"\"\"\n    Convert the density matrix to a PennyLane QubitDensityMatrix.\n    :param wires: List of wires to apply the density matrix to\n    :return: PennyLane QubitDensityMatrix object\n    \"\"\"\n    wires = wires if wires is not None else range(self.num_qubits)\n    return qml.QubitDensityMatrix(self, wires=wires)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert the density matrix to a Qiskit DensityMatrix object. :return: Qiskit DensityMatrix object</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def to_qiskit(self) -&gt; qiskit.quantum_info.DensityMatrix:\n    \"\"\"\n    Convert the density matrix to a Qiskit DensityMatrix object.\n    :return: Qiskit DensityMatrix object\n    \"\"\"\n    return qiskit.quantum_info.DensityMatrix(self)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.trace_equal_to_one","title":"<code>trace_equal_to_one()</code>","text":"<p>Trace of density matrix is equal to one.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def trace_equal_to_one(self) -&gt; bool:\n    \"\"\"Trace of density matrix is equal to one.\"\"\"\n    return np.isclose(np.trace(self), 1)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DensityMatrix.trace_norm","title":"<code>trace_norm()</code>","text":"<p>Trace norm of the density matrix.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def trace_norm(self) -&gt; float:\n    \"\"\"Trace norm of the density matrix.\"\"\"\n    return np.trace(np.sqrt(self.conjugate_transpose() @ self))\n</code></pre>"},{"location":"api/quantum-info/#thermal-states","title":"Thermal States","text":""},{"location":"api/quantum-info/#skq.quantum_info.GibbsState","title":"<code>skq.quantum_info.GibbsState</code>","text":"<p>               Bases: <code>DensityMatrix</code></p> <p>Gibbs (mixed) state representation of a quantum state in thermal equilibrium. :param hamiltonian: Hamiltonian matrix of the system :param temperature: Temperature of the system in Kelvin</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>class GibbsState(DensityMatrix):\n    \"\"\"\n    Gibbs (mixed) state representation of a quantum state in thermal equilibrium.\n    :param hamiltonian: Hamiltonian matrix of the system\n    :param temperature: Temperature of the system in Kelvin\n    \"\"\"\n\n    def __new__(cls, hamiltonian: np.array, temperature: float):\n        cls.hamiltonian = hamiltonian\n        cls.temperature = temperature\n        cls.beta = 1 / (BOLTZMANN_CONSTANT * temperature)\n        cls.exp_neg_beta_H = expm(-cls.beta * hamiltonian)\n        cls.partition_function = np.trace(cls.exp_neg_beta_H)\n        density_matrix = cls.exp_neg_beta_H / cls.partition_function\n        return super().__new__(cls, density_matrix)\n\n    def free_energy(self) -&gt; float:\n        \"\"\"Helmholtz free energy.\"\"\"\n        return -BOLTZMANN_CONSTANT * self.temperature * np.log(self.partition_function)\n\n    def heat_capacity(self) -&gt; float:\n        \"\"\"Calculate the heat capacity.\"\"\"\n        beta = 1 / (BOLTZMANN_CONSTANT * self.temperature)\n        energy_squared = np.trace(self @ self.hamiltonian @ self.hamiltonian)\n        energy_mean = self.internal_energy(self.hamiltonian) ** 2\n        return beta**2 * (energy_squared - energy_mean)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.GibbsState.free_energy","title":"<code>free_energy()</code>","text":"<p>Helmholtz free energy.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def free_energy(self) -&gt; float:\n    \"\"\"Helmholtz free energy.\"\"\"\n    return -BOLTZMANN_CONSTANT * self.temperature * np.log(self.partition_function)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.GibbsState.heat_capacity","title":"<code>heat_capacity()</code>","text":"<p>Calculate the heat capacity.</p> Source code in <code>src/skq/quantum_info/density.py</code> <pre><code>def heat_capacity(self) -&gt; float:\n    \"\"\"Calculate the heat capacity.\"\"\"\n    beta = 1 / (BOLTZMANN_CONSTANT * self.temperature)\n    energy_squared = np.trace(self @ self.hamiltonian @ self.hamiltonian)\n    energy_mean = self.internal_energy(self.hamiltonian) ** 2\n    return beta**2 * (energy_squared - energy_mean)\n</code></pre>"},{"location":"api/quantum-info/#quantum-channels","title":"Quantum Channels","text":"<p>Quantum channels represent physical operations on quantum states.</p> <pre><code>from skq.quantum_info import DepolarizingChannel\n\n# Create a depolarizing channel with 10% noise\nchannel = DepolarizingChannel(0.1)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel","title":"<code>skq.quantum_info.QuantumChannel</code>","text":"<p>               Bases: <code>SuperOperator</code></p> <p>Quantum Channel representation in choi, stinespring, or kraus form.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>class QuantumChannel(SuperOperator):\n    \"\"\"Quantum Channel representation in choi, stinespring, or kraus form.\"\"\"\n\n    def __new__(cls, input_array: np.array, representation=\"choi\"):\n        cls.representation = representation\n        obj = super().__new__(cls, input_array)\n        if cls.representation == \"choi\":\n            obj._validate_choi()\n        elif cls.representation == \"stinespring\":\n            obj._validate_stinespring()\n        elif cls.representation == \"kraus\":\n            obj._validate_kraus()\n        else:\n            raise ValueError(\"Invalid representation. Choose from 'choi', 'stinespring', or 'kraus'.\")\n        return obj\n\n    def _validate_choi(self):\n        \"\"\"Validate if the input matrix is a valid choi matrix.\"\"\"\n        assert self.is_nd(2), \"Choi matrix must be a 2D matrix.\"\n        assert self.is_square(), \"Choi matrix must be a square matrix.\"\n        assert self.is_positive_semidefinite(), \"Choi matrix must be positive semidefinite.\"\n        assert self.is_trace_preserving(), \"Choi matrix must be trace-preserving.\"\n\n    def _validate_stinespring(self):\n        \"\"\"Validate if the input matrix is a valid stinespring matrix.\"\"\"\n        assert self.is_nd(2), \"Stringspring matrix must be a 2D matrix.\"\n        assert self.is_isometry(), \"Stinespring matrix must be an isometry.\"\n        assert self.shape[0] &gt; self.shape[1], \"Stinespring matrix must have more rows than columns.\"\n\n    def _validate_kraus(self):\n        \"\"\"Validate if the input list of matrices is a valid kraus representation.\"\"\"\n        assert self.is_nd(3), \"Kraus operators must be 3D matrices.\"\n        for kraus_op in self:\n            assert kraus_op.shape[0] == kraus_op.shape[1], \"Each Kraus operator must be a square matrix.\"\n        assert self.is_trace_preserving(), \"Sum of outer products of kraus operators must be identity.\"\n\n    def is_nd(self, n: int) -&gt; bool:\n        \"\"\"Channel is an n-dimensional matrix.\"\"\"\n        return self.ndim == n\n\n    def is_square(self) -&gt; bool:\n        \"\"\"Check if the superoperator is represented by a square matrix.\"\"\"\n        return self.shape[0] == self.shape[1]\n\n    def is_positive_semidefinite(self) -&gt; bool:\n        \"\"\"Check if channel is positive semidefinite (i.e. all eigenvalues are non-negative).\n        Requirement for choi matrices.\"\"\"\n        eigenvalues = np.linalg.eigvalsh(self)\n        return np.all(eigenvalues &gt;= 0)\n\n    def is_trace_preserving(self) -&gt; bool:\n        \"\"\"Check if the quantum channel is trace-preserving.\"\"\"\n        if self.representation == \"kraus\":\n            d = self[0].shape[0]\n            kraus_sum = sum([np.dot(k.conjugate_transpose(), k) for k in self])\n            return np.allclose(kraus_sum, np.eye(d))\n        elif self.representation == \"choi\":\n            d = int(np.sqrt(self.shape[0]))\n            choi_reshaped = self.reshape(d, d, d, d)\n            partial_trace = np.trace(choi_reshaped, axis1=1, axis2=3)\n            return np.allclose(partial_trace, np.eye(d)) or np.isclose(np.trace(partial_trace), 1.0)\n        else:\n            raise ValueError(f\"Trace-preserving check is not implemented for representation '{self.representation}'.\")\n\n    def is_isometry(self) -&gt; bool:\n        \"\"\"\n        Check if the quantum channel is an isometry.\n        An isometry is a linear transformation that preserves distances (V^dagger V = I)\n        \"\"\"\n        return np.allclose(self.conjugate_transpose() @ self, np.eye(self.shape[1]))\n\n    def compose(self, other: \"QuantumChannel\") -&gt; \"QuantumChannel\":\n        \"\"\"\n        Compose quantum channels.\n        :param other: QuantumChannel object to compose with.\n        :return: Composed QuantumChannel object in the Kraus representation.\n        \"\"\"\n        assert isinstance(other, QuantumChannel), \"Input must be a QuantumChannel.\"\n        self_kraus = self.to_kraus()\n        other_kraus = other.to_kraus()\n        composed_kraus = []\n\n        for k1 in self_kraus:\n            for k2 in other_kraus:\n                composed_kraus.append(np.dot(k1, k2))\n\n        composed_kraus = np.array(composed_kraus, dtype=complex)\n        kraus_sum = sum(np.dot(k.conj().T, k) for k in composed_kraus)\n        normalization_factor = np.linalg.inv(sqrtm(kraus_sum).astype(np.complex128))\n        normalized_kraus = [np.dot(normalization_factor, k) for k in composed_kraus]\n        return QuantumChannel(np.array(normalized_kraus), representation=\"kraus\")\n\n    def tensor(self, other: \"QuantumChannel\") -&gt; \"QuantumChannel\":\n        \"\"\"\n        Tensor product with another channel.\n        :param other: QuantumChannel object to tensor with.\n        :return: QuantumChannel object in the Choi representation\n        \"\"\"\n        assert isinstance(other, QuantumChannel), \"The other object must be a QuantumChannel.\"\n        return QuantumChannel(np.kron(self.to_choi(), other.to_choi()), representation=\"choi\")\n\n    def fidelity(self, other: \"QuantumChannel\") -&gt; float:\n        \"\"\"\n        Fidelity between two quantum channels.\n        :param other: QuantumChannel object to calculate fidelity with.\n        :return: Fidelity in range [0...1].\n        \"\"\"\n        assert isinstance(other, QuantumChannel), \"The other object must be a QuantumChannel.\"\n        choi_self = self.to_choi()\n        choi_other = other.to_choi()\n        norm_choi_self = choi_self / np.trace(choi_self)\n        norm_choi_other = choi_other / np.trace(choi_other)\n        sqrt_choi_self = sqrtm(norm_choi_self)\n\n        product_matrix = sqrt_choi_self @ norm_choi_other @ sqrt_choi_self\n        fidelity_value = np.trace(sqrtm(product_matrix)) ** 2\n        fidelity_value = np.real(fidelity_value)\n        fidelity_value = min(max(fidelity_value, 0), 1)\n        return fidelity_value\n\n    def to_choi(self):\n        \"\"\"Convert the channel to the choi matrix representation.\"\"\"\n        if self.representation == \"choi\":\n            return self\n        elif self.representation == \"stinespring\":\n            return self._stinespring_to_choi()\n        elif self.representation == \"kraus\":\n            return self._kraus_to_choi()\n\n    def to_stinespring(self):\n        \"\"\"Convert the channel to the stinespring representation.\"\"\"\n        if self.representation == \"stinespring\":\n            return self\n        elif self.representation == \"choi\":\n            return self._choi_to_stinespring()\n        elif self.representation == \"kraus\":\n            return self._kraus_to_stinespring()\n\n    def to_kraus(self):\n        \"\"\"Convert the channel to the kraus representation.\"\"\"\n        if self.representation == \"kraus\":\n            return self\n        elif self.representation == \"choi\":\n            return self._choi_to_kraus()\n        elif self.representation == \"stinespring\":\n            return self._stinespring_to_kraus()\n\n    def _stinespring_to_choi(self) -&gt; \"QuantumChannel\":\n        \"\"\"Convert stinespring representation to choi matrix.\"\"\"\n        return QuantumChannel(np.dot(self, self.conjugate_transpose()), representation=\"choi\")\n\n    def _choi_to_stinespring(self) -&gt; \"QuantumChannel\":\n        \"\"\"Convert choi matrix to stinespring representation.\"\"\"\n        d = int(np.sqrt(self.shape[0]))\n        w, v = np.linalg.eigh(self)\n        # Filter out small eigenvalues to avoid numerical instability\n        non_zero_indices = np.where(w &gt; 1e-10)[0]\n        sqrt_eigenvals = np.sqrt(w[non_zero_indices])\n        v = v[:, non_zero_indices]\n        r = len(non_zero_indices)\n        stinespring_matrix = np.zeros((d * r, d), dtype=complex)\n        for i in range(r):\n            stinespring_matrix[i * d : (i + 1) * d, :] = sqrt_eigenvals[i] * v[:, i].reshape(d, d)\n        return QuantumChannel(stinespring_matrix, representation=\"stinespring\")\n\n    def _kraus_to_choi(self) -&gt; \"QuantumChannel\":\n        \"\"\"Convert Kraus representation to Choi matrix using vectorization.\"\"\"\n        d = self[0].shape[0]\n        choi_matrix = np.zeros((d * d, d * d), dtype=complex)\n        for k in self:\n            choi_matrix += np.kron(k, k.conj())\n        return QuantumChannel(choi_matrix / d, representation=\"choi\")\n\n    def _choi_to_kraus(self) -&gt; \"QuantumChannel\":\n        \"\"\"Convert choi matrix to kraus operators.\"\"\"\n        d = int(np.sqrt(self.shape[0]))\n        kraus_operators = []\n        w, v = np.linalg.eigh(self)\n        for i in range(len(w)):\n            if np.isclose(w[i], 0):\n                continue\n            kraus_operators.append(np.sqrt(w[i]) * v[:, i].reshape(d, d))\n        return QuantumChannel(np.array(kraus_operators, dtype=complex), representation=\"kraus\")\n\n    def _kraus_to_stinespring(self) -&gt; \"QuantumChannel\":\n        \"\"\"Convert kraus representation to stinespring representation.\"\"\"\n        d = self[0].shape[0]\n        num_kraus = len(self)\n        stinespring_matrix = np.zeros((d * num_kraus, d), dtype=complex)\n        for i, k in enumerate(self):\n            stinespring_matrix[i * d : (i + 1) * d, :] = k\n        return QuantumChannel(stinespring_matrix, representation=\"stinespring\")\n\n    def _stinespring_to_kraus(self) -&gt; \"QuantumChannel\":\n        \"\"\"Convert stinespring representation to kraus operators.\"\"\"\n        d = self.shape[1]\n        num_kraus = self.shape[0] // d\n        kraus_operators = []\n        for i in range(num_kraus):\n            kraus_operators.append(self[i * d : (i + 1) * d, :])\n        return QuantumChannel(np.array(kraus_operators, dtype=complex), representation=\"kraus\")\n\n    def __call__(self, density_matrix: DensityMatrix) -&gt; DensityMatrix:\n        rho_out = np.zeros_like(density_matrix, dtype=complex)\n        for K in self.to_kraus():\n            rho_out += K @ density_matrix @ K.conj().T\n        return DensityMatrix(rho_out)\n\n    def to_qiskit(self) -&gt; qiskit.quantum_info.operators.channel.quantum_channel.QuantumChannel:\n        \"\"\"Convert the channel to a Qiskit object.\"\"\"\n        if self.representation == \"kraus\":\n            # Input must be a list of numpy arrays\n            kraus_list = [self[i] for i in range(self.shape[0])]\n            return qiskit.quantum_info.Kraus(kraus_list)\n        elif self.representation == \"stinespring\":\n            return qiskit.quantum_info.Stinespring(self)\n        elif self.representation == \"choi\":\n            return qiskit.quantum_info.Choi(self)\n\n    def from_qiskit(self, channel: qiskit.quantum_info.operators.channel.quantum_channel.QuantumChannel) -&gt; \"QuantumChannel\":\n        \"\"\"Convert a Qiskit channel to a QuantumChannel object.\"\"\"\n        if isinstance(channel, qiskit.quantum_info.Kraus):\n            return QuantumChannel(channel.data, representation=\"kraus\")\n        elif isinstance(channel, qiskit.quantum_info.Stinespring):\n            return QuantumChannel(channel.data, representation=\"stinespring\")\n        elif isinstance(channel, qiskit.quantum_info.Choi):\n            return QuantumChannel(channel.data, representation=\"choi\")\n        else:\n            raise ValueError(f\"Invalid Qiskit channel type '{channel}'.\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel._choi_to_kraus","title":"<code>_choi_to_kraus()</code>","text":"<p>Convert choi matrix to kraus operators.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def _choi_to_kraus(self) -&gt; \"QuantumChannel\":\n    \"\"\"Convert choi matrix to kraus operators.\"\"\"\n    d = int(np.sqrt(self.shape[0]))\n    kraus_operators = []\n    w, v = np.linalg.eigh(self)\n    for i in range(len(w)):\n        if np.isclose(w[i], 0):\n            continue\n        kraus_operators.append(np.sqrt(w[i]) * v[:, i].reshape(d, d))\n    return QuantumChannel(np.array(kraus_operators, dtype=complex), representation=\"kraus\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel._choi_to_stinespring","title":"<code>_choi_to_stinespring()</code>","text":"<p>Convert choi matrix to stinespring representation.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def _choi_to_stinespring(self) -&gt; \"QuantumChannel\":\n    \"\"\"Convert choi matrix to stinespring representation.\"\"\"\n    d = int(np.sqrt(self.shape[0]))\n    w, v = np.linalg.eigh(self)\n    # Filter out small eigenvalues to avoid numerical instability\n    non_zero_indices = np.where(w &gt; 1e-10)[0]\n    sqrt_eigenvals = np.sqrt(w[non_zero_indices])\n    v = v[:, non_zero_indices]\n    r = len(non_zero_indices)\n    stinespring_matrix = np.zeros((d * r, d), dtype=complex)\n    for i in range(r):\n        stinespring_matrix[i * d : (i + 1) * d, :] = sqrt_eigenvals[i] * v[:, i].reshape(d, d)\n    return QuantumChannel(stinespring_matrix, representation=\"stinespring\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel._kraus_to_choi","title":"<code>_kraus_to_choi()</code>","text":"<p>Convert Kraus representation to Choi matrix using vectorization.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def _kraus_to_choi(self) -&gt; \"QuantumChannel\":\n    \"\"\"Convert Kraus representation to Choi matrix using vectorization.\"\"\"\n    d = self[0].shape[0]\n    choi_matrix = np.zeros((d * d, d * d), dtype=complex)\n    for k in self:\n        choi_matrix += np.kron(k, k.conj())\n    return QuantumChannel(choi_matrix / d, representation=\"choi\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel._kraus_to_stinespring","title":"<code>_kraus_to_stinespring()</code>","text":"<p>Convert kraus representation to stinespring representation.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def _kraus_to_stinespring(self) -&gt; \"QuantumChannel\":\n    \"\"\"Convert kraus representation to stinespring representation.\"\"\"\n    d = self[0].shape[0]\n    num_kraus = len(self)\n    stinespring_matrix = np.zeros((d * num_kraus, d), dtype=complex)\n    for i, k in enumerate(self):\n        stinespring_matrix[i * d : (i + 1) * d, :] = k\n    return QuantumChannel(stinespring_matrix, representation=\"stinespring\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel._stinespring_to_choi","title":"<code>_stinespring_to_choi()</code>","text":"<p>Convert stinespring representation to choi matrix.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def _stinespring_to_choi(self) -&gt; \"QuantumChannel\":\n    \"\"\"Convert stinespring representation to choi matrix.\"\"\"\n    return QuantumChannel(np.dot(self, self.conjugate_transpose()), representation=\"choi\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel._stinespring_to_kraus","title":"<code>_stinespring_to_kraus()</code>","text":"<p>Convert stinespring representation to kraus operators.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def _stinespring_to_kraus(self) -&gt; \"QuantumChannel\":\n    \"\"\"Convert stinespring representation to kraus operators.\"\"\"\n    d = self.shape[1]\n    num_kraus = self.shape[0] // d\n    kraus_operators = []\n    for i in range(num_kraus):\n        kraus_operators.append(self[i * d : (i + 1) * d, :])\n    return QuantumChannel(np.array(kraus_operators, dtype=complex), representation=\"kraus\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel._validate_choi","title":"<code>_validate_choi()</code>","text":"<p>Validate if the input matrix is a valid choi matrix.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def _validate_choi(self):\n    \"\"\"Validate if the input matrix is a valid choi matrix.\"\"\"\n    assert self.is_nd(2), \"Choi matrix must be a 2D matrix.\"\n    assert self.is_square(), \"Choi matrix must be a square matrix.\"\n    assert self.is_positive_semidefinite(), \"Choi matrix must be positive semidefinite.\"\n    assert self.is_trace_preserving(), \"Choi matrix must be trace-preserving.\"\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel._validate_kraus","title":"<code>_validate_kraus()</code>","text":"<p>Validate if the input list of matrices is a valid kraus representation.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def _validate_kraus(self):\n    \"\"\"Validate if the input list of matrices is a valid kraus representation.\"\"\"\n    assert self.is_nd(3), \"Kraus operators must be 3D matrices.\"\n    for kraus_op in self:\n        assert kraus_op.shape[0] == kraus_op.shape[1], \"Each Kraus operator must be a square matrix.\"\n    assert self.is_trace_preserving(), \"Sum of outer products of kraus operators must be identity.\"\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel._validate_stinespring","title":"<code>_validate_stinespring()</code>","text":"<p>Validate if the input matrix is a valid stinespring matrix.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def _validate_stinespring(self):\n    \"\"\"Validate if the input matrix is a valid stinespring matrix.\"\"\"\n    assert self.is_nd(2), \"Stringspring matrix must be a 2D matrix.\"\n    assert self.is_isometry(), \"Stinespring matrix must be an isometry.\"\n    assert self.shape[0] &gt; self.shape[1], \"Stinespring matrix must have more rows than columns.\"\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.compose","title":"<code>compose(other)</code>","text":"<p>Compose quantum channels. :param other: QuantumChannel object to compose with. :return: Composed QuantumChannel object in the Kraus representation.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def compose(self, other: \"QuantumChannel\") -&gt; \"QuantumChannel\":\n    \"\"\"\n    Compose quantum channels.\n    :param other: QuantumChannel object to compose with.\n    :return: Composed QuantumChannel object in the Kraus representation.\n    \"\"\"\n    assert isinstance(other, QuantumChannel), \"Input must be a QuantumChannel.\"\n    self_kraus = self.to_kraus()\n    other_kraus = other.to_kraus()\n    composed_kraus = []\n\n    for k1 in self_kraus:\n        for k2 in other_kraus:\n            composed_kraus.append(np.dot(k1, k2))\n\n    composed_kraus = np.array(composed_kraus, dtype=complex)\n    kraus_sum = sum(np.dot(k.conj().T, k) for k in composed_kraus)\n    normalization_factor = np.linalg.inv(sqrtm(kraus_sum).astype(np.complex128))\n    normalized_kraus = [np.dot(normalization_factor, k) for k in composed_kraus]\n    return QuantumChannel(np.array(normalized_kraus), representation=\"kraus\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.fidelity","title":"<code>fidelity(other)</code>","text":"<p>Fidelity between two quantum channels. :param other: QuantumChannel object to calculate fidelity with. :return: Fidelity in range [0...1].</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def fidelity(self, other: \"QuantumChannel\") -&gt; float:\n    \"\"\"\n    Fidelity between two quantum channels.\n    :param other: QuantumChannel object to calculate fidelity with.\n    :return: Fidelity in range [0...1].\n    \"\"\"\n    assert isinstance(other, QuantumChannel), \"The other object must be a QuantumChannel.\"\n    choi_self = self.to_choi()\n    choi_other = other.to_choi()\n    norm_choi_self = choi_self / np.trace(choi_self)\n    norm_choi_other = choi_other / np.trace(choi_other)\n    sqrt_choi_self = sqrtm(norm_choi_self)\n\n    product_matrix = sqrt_choi_self @ norm_choi_other @ sqrt_choi_self\n    fidelity_value = np.trace(sqrtm(product_matrix)) ** 2\n    fidelity_value = np.real(fidelity_value)\n    fidelity_value = min(max(fidelity_value, 0), 1)\n    return fidelity_value\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.from_qiskit","title":"<code>from_qiskit(channel)</code>","text":"<p>Convert a Qiskit channel to a QuantumChannel object.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def from_qiskit(self, channel: qiskit.quantum_info.operators.channel.quantum_channel.QuantumChannel) -&gt; \"QuantumChannel\":\n    \"\"\"Convert a Qiskit channel to a QuantumChannel object.\"\"\"\n    if isinstance(channel, qiskit.quantum_info.Kraus):\n        return QuantumChannel(channel.data, representation=\"kraus\")\n    elif isinstance(channel, qiskit.quantum_info.Stinespring):\n        return QuantumChannel(channel.data, representation=\"stinespring\")\n    elif isinstance(channel, qiskit.quantum_info.Choi):\n        return QuantumChannel(channel.data, representation=\"choi\")\n    else:\n        raise ValueError(f\"Invalid Qiskit channel type '{channel}'.\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.is_isometry","title":"<code>is_isometry()</code>","text":"<p>Check if the quantum channel is an isometry. An isometry is a linear transformation that preserves distances (V^dagger V = I)</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def is_isometry(self) -&gt; bool:\n    \"\"\"\n    Check if the quantum channel is an isometry.\n    An isometry is a linear transformation that preserves distances (V^dagger V = I)\n    \"\"\"\n    return np.allclose(self.conjugate_transpose() @ self, np.eye(self.shape[1]))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.is_nd","title":"<code>is_nd(n)</code>","text":"<p>Channel is an n-dimensional matrix.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def is_nd(self, n: int) -&gt; bool:\n    \"\"\"Channel is an n-dimensional matrix.\"\"\"\n    return self.ndim == n\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.is_positive_semidefinite","title":"<code>is_positive_semidefinite()</code>","text":"<p>Check if channel is positive semidefinite (i.e. all eigenvalues are non-negative). Requirement for choi matrices.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def is_positive_semidefinite(self) -&gt; bool:\n    \"\"\"Check if channel is positive semidefinite (i.e. all eigenvalues are non-negative).\n    Requirement for choi matrices.\"\"\"\n    eigenvalues = np.linalg.eigvalsh(self)\n    return np.all(eigenvalues &gt;= 0)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.is_square","title":"<code>is_square()</code>","text":"<p>Check if the superoperator is represented by a square matrix.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def is_square(self) -&gt; bool:\n    \"\"\"Check if the superoperator is represented by a square matrix.\"\"\"\n    return self.shape[0] == self.shape[1]\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.is_trace_preserving","title":"<code>is_trace_preserving()</code>","text":"<p>Check if the quantum channel is trace-preserving.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def is_trace_preserving(self) -&gt; bool:\n    \"\"\"Check if the quantum channel is trace-preserving.\"\"\"\n    if self.representation == \"kraus\":\n        d = self[0].shape[0]\n        kraus_sum = sum([np.dot(k.conjugate_transpose(), k) for k in self])\n        return np.allclose(kraus_sum, np.eye(d))\n    elif self.representation == \"choi\":\n        d = int(np.sqrt(self.shape[0]))\n        choi_reshaped = self.reshape(d, d, d, d)\n        partial_trace = np.trace(choi_reshaped, axis1=1, axis2=3)\n        return np.allclose(partial_trace, np.eye(d)) or np.isclose(np.trace(partial_trace), 1.0)\n    else:\n        raise ValueError(f\"Trace-preserving check is not implemented for representation '{self.representation}'.\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.tensor","title":"<code>tensor(other)</code>","text":"<p>Tensor product with another channel. :param other: QuantumChannel object to tensor with. :return: QuantumChannel object in the Choi representation</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def tensor(self, other: \"QuantumChannel\") -&gt; \"QuantumChannel\":\n    \"\"\"\n    Tensor product with another channel.\n    :param other: QuantumChannel object to tensor with.\n    :return: QuantumChannel object in the Choi representation\n    \"\"\"\n    assert isinstance(other, QuantumChannel), \"The other object must be a QuantumChannel.\"\n    return QuantumChannel(np.kron(self.to_choi(), other.to_choi()), representation=\"choi\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.to_choi","title":"<code>to_choi()</code>","text":"<p>Convert the channel to the choi matrix representation.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def to_choi(self):\n    \"\"\"Convert the channel to the choi matrix representation.\"\"\"\n    if self.representation == \"choi\":\n        return self\n    elif self.representation == \"stinespring\":\n        return self._stinespring_to_choi()\n    elif self.representation == \"kraus\":\n        return self._kraus_to_choi()\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.to_kraus","title":"<code>to_kraus()</code>","text":"<p>Convert the channel to the kraus representation.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def to_kraus(self):\n    \"\"\"Convert the channel to the kraus representation.\"\"\"\n    if self.representation == \"kraus\":\n        return self\n    elif self.representation == \"choi\":\n        return self._choi_to_kraus()\n    elif self.representation == \"stinespring\":\n        return self._stinespring_to_kraus()\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert the channel to a Qiskit object.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def to_qiskit(self) -&gt; qiskit.quantum_info.operators.channel.quantum_channel.QuantumChannel:\n    \"\"\"Convert the channel to a Qiskit object.\"\"\"\n    if self.representation == \"kraus\":\n        # Input must be a list of numpy arrays\n        kraus_list = [self[i] for i in range(self.shape[0])]\n        return qiskit.quantum_info.Kraus(kraus_list)\n    elif self.representation == \"stinespring\":\n        return qiskit.quantum_info.Stinespring(self)\n    elif self.representation == \"choi\":\n        return qiskit.quantum_info.Choi(self)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.QuantumChannel.to_stinespring","title":"<code>to_stinespring()</code>","text":"<p>Convert the channel to the stinespring representation.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>def to_stinespring(self):\n    \"\"\"Convert the channel to the stinespring representation.\"\"\"\n    if self.representation == \"stinespring\":\n        return self\n    elif self.representation == \"choi\":\n        return self._choi_to_stinespring()\n    elif self.representation == \"kraus\":\n        return self._kraus_to_stinespring()\n</code></pre>"},{"location":"api/quantum-info/#predefined-channels","title":"Predefined Channels","text":""},{"location":"api/quantum-info/#skq.quantum_info.QubitResetChannel","title":"<code>skq.quantum_info.QubitResetChannel</code>","text":"<p>               Bases: <code>QuantumChannel</code></p> <p>Reset channel for a qubit system. Initialized in the Kraus representation.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>class QubitResetChannel(QuantumChannel):\n    \"\"\"\n    Reset channel for a qubit system.\n    Initialized in the Kraus representation.\n    \"\"\"\n\n    def __new__(cls):\n        kraus_ops = np.array([[[1, 0], [0, 0]], [[0, 1], [0, 0]]])\n        return super().__new__(cls, kraus_ops, representation=\"kraus\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.DepolarizingChannel","title":"<code>skq.quantum_info.DepolarizingChannel</code>","text":"<p>               Bases: <code>QuantumChannel</code></p> <p>Depolarizing noise (qubit) channel as Kraus representation. Special case of PauliNoiseChannel for p_x = p_y = p_z. :param p: Probability of depolarization.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>class DepolarizingChannel(QuantumChannel):\n    \"\"\"\n    Depolarizing noise (qubit) channel as Kraus representation.\n    Special case of PauliNoiseChannel for p_x = p_y = p_z.\n    :param p: Probability of depolarization.\n    \"\"\"\n\n    def __new__(cls, p: float):\n        assert 0 &lt;= p &lt;= 1, \"Depolarization probability must be in range [0...1].\"\n        cls.p = p\n        kraus_ops = np.array([np.sqrt(1 - p) * I(), np.sqrt(p / 3) * X(), np.sqrt(p / 3) * Y(), np.sqrt(p / 3) * Z()])\n        return super().__new__(cls, kraus_ops, representation=\"kraus\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.PauliNoiseChannel","title":"<code>skq.quantum_info.PauliNoiseChannel</code>","text":"<p>               Bases: <code>QuantumChannel</code></p> <p>Pauli noise channel as Kraus representation. :param p_x: Probability of X error. :param p_y: Probability of Y error. :param p_z: Probability of Z error.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>class PauliNoiseChannel(QuantumChannel):\n    \"\"\"\n    Pauli noise channel as Kraus representation.\n    :param p_x: Probability of X error.\n    :param p_y: Probability of Y error.\n    :param p_z: Probability of Z error.\n    \"\"\"\n\n    def __new__(cls, p_x: float, p_y: float, p_z: float):\n        # Ensure the probabilities are within [0, 1] and the total does not exceed 1\n        assert 0 &lt;= p_x &lt;= 1, \"Probability p_x must be in range [0...1].\"\n        assert 0 &lt;= p_y &lt;= 1, \"Probability p_y must be in range [0...1].\"\n        assert 0 &lt;= p_z &lt;= 1, \"Probability p_z must be in range [0...1].\"\n        total_p = p_x + p_y + p_z\n        assert total_p &lt;= 1, \"The sum of probabilities p_x, p_y, and p_z must not exceed 1.\"\n\n        p_i = 1 - total_p\n        kraus_ops = np.array([np.sqrt(p_i) * I(), np.sqrt(p_x) * X(), np.sqrt(p_y) * Y(), np.sqrt(p_z) * Z()])\n        return super().__new__(cls, kraus_ops, representation=\"kraus\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.CompletelyDephasingChannel","title":"<code>skq.quantum_info.CompletelyDephasingChannel</code>","text":"<p>               Bases: <code>QuantumChannel</code></p> <p>Dephases a quantum (qubit) state in the computational basis. Initialized in the Kraus representation.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>class CompletelyDephasingChannel(QuantumChannel):\n    \"\"\"\n    Dephases a quantum (qubit) state in the computational basis.\n    Initialized in the Kraus representation.\n    \"\"\"\n\n    def __new__(cls):\n        kraus_ops = np.array([np.diag([1 if i == j else 0 for j in range(2)]) for i in range(2)])\n        return super().__new__(cls, kraus_ops, representation=\"kraus\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.AmplitudeDampingChannel","title":"<code>skq.quantum_info.AmplitudeDampingChannel</code>","text":"<p>               Bases: <code>QuantumChannel</code></p> <p>Amplitude Damping Channel for a quantum (qubit) system. :param gamma: Damping parameter in range [0...1].</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>class AmplitudeDampingChannel(QuantumChannel):\n    \"\"\"\n    Amplitude Damping Channel for a quantum (qubit) system.\n    :param gamma: Damping parameter in range [0...1].\n    \"\"\"\n\n    def __new__(cls, gamma: float):\n        assert 0 &lt;= gamma &lt;= 1, \"Gamma must be in range [0...1].\"\n        cls.gamma = gamma\n        kraus_ops = np.array([[[1, 0], [0, np.sqrt(1 - gamma)]], [[0, np.sqrt(gamma)], [0, 0]]])\n        return super().__new__(cls, kraus_ops, representation=\"kraus\")\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.PhaseFlipChannel","title":"<code>skq.quantum_info.PhaseFlipChannel</code>","text":"<p>               Bases: <code>QuantumChannel</code></p> <p>Phase flip channel for a qubit system. Initialized in the Kraus representation. :param p: Probability of phase flip.</p> Source code in <code>src/skq/quantum_info/channel.py</code> <pre><code>class PhaseFlipChannel(QuantumChannel):\n    \"\"\"\n    Phase flip channel for a qubit system.\n    Initialized in the Kraus representation.\n    :param p: Probability of phase flip.\n    \"\"\"\n\n    def __new__(cls, p: float):\n        assert 0 &lt;= p &lt;= 1, \"Depolarization probability must be in range [0...1].\"\n        cls.p = p\n        kraus_ops = np.array([np.sqrt(1 - p) * I(), np.sqrt(p) * Z()])\n        return super().__new__(cls, kraus_ops, representation=\"kraus\")\n</code></pre>"},{"location":"api/quantum-info/#hamiltonians","title":"Hamiltonians","text":"<p>Hamiltonians represent the energy of quantum systems.</p> <pre><code>from skq.quantum_info import Hamiltonian, IsingHamiltonian\n\n# Create an Ising model Hamiltonian for 3 qubits\nH = IsingHamiltonian(num_qubits=3, J=1.0, h=0.5)\nprint(H.ground_state_energy())\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian","title":"<code>skq.quantum_info.Hamiltonian</code>","text":"<p>               Bases: <code>HermitianOperator</code></p> <p>Class representing a Hamiltonian in quantum computing.</p> <p>:param input_array: The input array representing the Hamiltonian. Will be converted to a complex numpy array. :param hbar: The reduced Planck constant. Default is 1.0 (natural units). If you want to use the actual physical value, set hbar to 1.0545718e-34.</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>class Hamiltonian(HermitianOperator):\n    \"\"\"\n    Class representing a Hamiltonian in quantum computing.\n\n    :param input_array: The input array representing the Hamiltonian. Will be converted to a complex numpy array.\n    :param hbar: The reduced Planck constant. Default is 1.0 (natural units).\n    If you want to use the actual physical value, set hbar to 1.0545718e-34.\n    \"\"\"\n\n    def __new__(cls, input_array, hbar: float = 1.0):\n        assert hbar &gt; 0, \"The reduced Planck constant must be greater than zero.\"\n        obj = super().__new__(cls, input_array)\n        obj.hbar = hbar\n        return obj\n\n    @property\n    def num_qubits(self) -&gt; int:\n        \"\"\"Number of qubits in the Hamiltonian.\"\"\"\n        return int(np.log2(self.shape[0]))\n\n    def is_multi_qubit(self) -&gt; bool:\n        \"\"\"Check if Hamiltonian involves multiple qubits.\"\"\"\n        return self.num_qubits &gt; 1\n\n    def time_evolution_operator(self, t: float) -&gt; np.ndarray:\n        \"\"\"Time evolution operator U(t) = exp(-iHt/hbar).\"\"\"\n        return scipy.linalg.expm(-1j * self * t / self.hbar)\n\n    def ground_state_energy(self) -&gt; float:\n        \"\"\"Ground state energy. i.e. the smallest eigenvalue.\"\"\"\n        eigenvalues = self.eigenvalues()\n        return eigenvalues[0]\n\n    def ground_state(self) -&gt; np.ndarray:\n        \"\"\"The eigenvector corresponding to the smallest eigenvalue.\"\"\"\n        _, eigenvectors = np.linalg.eigh(self)\n        return eigenvectors[:, 0]\n\n    def convert_endianness(self) -&gt; \"Hamiltonian\":\n        \"\"\"Hamiltonian from big-endian to little-endian and vice versa.\"\"\"\n        perm = np.argsort([int(bin(i)[2:].zfill(self.num_qubits)[::-1], 2) for i in range(2**self.num_qubits)])\n        return self[np.ix_(perm, perm)]\n\n    def add_noise(self, noise_strength: float, noise_operator: np.array) -&gt; \"Hamiltonian\":\n        \"\"\"\n        Add noise to the Hamiltonian.\n        :param noise_strength: Strength of the noise. Generally in range [0.0001, 0.5].\n        :param noise_operator: Operator representing the noise. For example Pauli matrices.\n        :return: A new Hamiltonian with noise added.\n        \"\"\"\n        assert noise_operator.shape == self.shape, \"Noise operator must have the same dimensions as the Hamiltonian.\"\n        return Hamiltonian(self + noise_strength * noise_operator, hbar=self.hbar)\n\n    def to_qiskit(self) -&gt; qiskit.quantum_info.Operator:\n        \"\"\"\n        Convert the scikit-q Hamiltonian to a Qiskit Operator object.\n        Qiskit using little endian convention, so we permute the order of the qubits.\n        :return: Qiskit Operator object\n        \"\"\"\n        return qiskit.quantum_info.Operator(self.convert_endianness())\n\n    @staticmethod\n    def from_qiskit(operator: qiskit.quantum_info.Operator) -&gt; \"Hamiltonian\":\n        \"\"\"\n        Create a scikit-q Hamiltonian object from a Qiskit Operator object.\n        Qiskit using little endian convention, so we permute the order of the qubits.\n        :param operator: Qiskit Operator object\n        :return: Hamiltonian object\n        \"\"\"\n        return Hamiltonian(operator.data).convert_endianness()\n\n    def to_pennylane(self, wires: list[int] | int = None, **kwargs) -&gt; \"qml.Hamiltonian\":\n        \"\"\"\n        Convert the scikit-q Hamiltonian to a PennyLane Hamiltonian.\n        :param wires: List of wires to apply the Hamiltonian to\n        kwargs are passed to the PennyLane Hamiltonian constructor.\n        :return: PennyLane Hamiltonian object\n        \"\"\"\n        coefficients = [1.0]\n        wires = wires if wires is not None else list(range(self.num_qubits))\n        observables = [qml.Hermitian(self, wires=wires)]\n        return qml.Hamiltonian(coefficients, observables, **kwargs)\n\n    @staticmethod\n    def from_pennylane(hamiltonian: qml.Hamiltonian) -&gt; \"Hamiltonian\":\n        \"\"\"\n        Convert a PennyLane Hamiltonian object to a scikit-q Hamiltonian object.\n        :param hamiltonian: PennyLane Hamiltonian object\n        :return: Hamiltonian object\n        \"\"\"\n        assert len(hamiltonian.ops) == 1, \"Only single-term Hamiltonians are supported.\"\n        return Hamiltonian(hamiltonian.ops[0].matrix())\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.num_qubits","title":"<code>num_qubits</code>  <code>property</code>","text":"<p>Number of qubits in the Hamiltonian.</p>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.add_noise","title":"<code>add_noise(noise_strength, noise_operator)</code>","text":"<p>Add noise to the Hamiltonian. :param noise_strength: Strength of the noise. Generally in range [0.0001, 0.5]. :param noise_operator: Operator representing the noise. For example Pauli matrices. :return: A new Hamiltonian with noise added.</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>def add_noise(self, noise_strength: float, noise_operator: np.array) -&gt; \"Hamiltonian\":\n    \"\"\"\n    Add noise to the Hamiltonian.\n    :param noise_strength: Strength of the noise. Generally in range [0.0001, 0.5].\n    :param noise_operator: Operator representing the noise. For example Pauli matrices.\n    :return: A new Hamiltonian with noise added.\n    \"\"\"\n    assert noise_operator.shape == self.shape, \"Noise operator must have the same dimensions as the Hamiltonian.\"\n    return Hamiltonian(self + noise_strength * noise_operator, hbar=self.hbar)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.convert_endianness","title":"<code>convert_endianness()</code>","text":"<p>Hamiltonian from big-endian to little-endian and vice versa.</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>def convert_endianness(self) -&gt; \"Hamiltonian\":\n    \"\"\"Hamiltonian from big-endian to little-endian and vice versa.\"\"\"\n    perm = np.argsort([int(bin(i)[2:].zfill(self.num_qubits)[::-1], 2) for i in range(2**self.num_qubits)])\n    return self[np.ix_(perm, perm)]\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.from_pennylane","title":"<code>from_pennylane(hamiltonian)</code>  <code>staticmethod</code>","text":"<p>Convert a PennyLane Hamiltonian object to a scikit-q Hamiltonian object. :param hamiltonian: PennyLane Hamiltonian object :return: Hamiltonian object</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>@staticmethod\ndef from_pennylane(hamiltonian: qml.Hamiltonian) -&gt; \"Hamiltonian\":\n    \"\"\"\n    Convert a PennyLane Hamiltonian object to a scikit-q Hamiltonian object.\n    :param hamiltonian: PennyLane Hamiltonian object\n    :return: Hamiltonian object\n    \"\"\"\n    assert len(hamiltonian.ops) == 1, \"Only single-term Hamiltonians are supported.\"\n    return Hamiltonian(hamiltonian.ops[0].matrix())\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.from_qiskit","title":"<code>from_qiskit(operator)</code>  <code>staticmethod</code>","text":"<p>Create a scikit-q Hamiltonian object from a Qiskit Operator object. Qiskit using little endian convention, so we permute the order of the qubits. :param operator: Qiskit Operator object :return: Hamiltonian object</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>@staticmethod\ndef from_qiskit(operator: qiskit.quantum_info.Operator) -&gt; \"Hamiltonian\":\n    \"\"\"\n    Create a scikit-q Hamiltonian object from a Qiskit Operator object.\n    Qiskit using little endian convention, so we permute the order of the qubits.\n    :param operator: Qiskit Operator object\n    :return: Hamiltonian object\n    \"\"\"\n    return Hamiltonian(operator.data).convert_endianness()\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.ground_state","title":"<code>ground_state()</code>","text":"<p>The eigenvector corresponding to the smallest eigenvalue.</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>def ground_state(self) -&gt; np.ndarray:\n    \"\"\"The eigenvector corresponding to the smallest eigenvalue.\"\"\"\n    _, eigenvectors = np.linalg.eigh(self)\n    return eigenvectors[:, 0]\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.ground_state_energy","title":"<code>ground_state_energy()</code>","text":"<p>Ground state energy. i.e. the smallest eigenvalue.</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>def ground_state_energy(self) -&gt; float:\n    \"\"\"Ground state energy. i.e. the smallest eigenvalue.\"\"\"\n    eigenvalues = self.eigenvalues()\n    return eigenvalues[0]\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.is_multi_qubit","title":"<code>is_multi_qubit()</code>","text":"<p>Check if Hamiltonian involves multiple qubits.</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>def is_multi_qubit(self) -&gt; bool:\n    \"\"\"Check if Hamiltonian involves multiple qubits.\"\"\"\n    return self.num_qubits &gt; 1\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.time_evolution_operator","title":"<code>time_evolution_operator(t)</code>","text":"<p>Time evolution operator U(t) = exp(-iHt/hbar).</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>def time_evolution_operator(self, t: float) -&gt; np.ndarray:\n    \"\"\"Time evolution operator U(t) = exp(-iHt/hbar).\"\"\"\n    return scipy.linalg.expm(-1j * self * t / self.hbar)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.to_pennylane","title":"<code>to_pennylane(wires=None, **kwargs)</code>","text":"<p>Convert the scikit-q Hamiltonian to a PennyLane Hamiltonian. :param wires: List of wires to apply the Hamiltonian to kwargs are passed to the PennyLane Hamiltonian constructor. :return: PennyLane Hamiltonian object</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>def to_pennylane(self, wires: list[int] | int = None, **kwargs) -&gt; \"qml.Hamiltonian\":\n    \"\"\"\n    Convert the scikit-q Hamiltonian to a PennyLane Hamiltonian.\n    :param wires: List of wires to apply the Hamiltonian to\n    kwargs are passed to the PennyLane Hamiltonian constructor.\n    :return: PennyLane Hamiltonian object\n    \"\"\"\n    coefficients = [1.0]\n    wires = wires if wires is not None else list(range(self.num_qubits))\n    observables = [qml.Hermitian(self, wires=wires)]\n    return qml.Hamiltonian(coefficients, observables, **kwargs)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.Hamiltonian.to_qiskit","title":"<code>to_qiskit()</code>","text":"<p>Convert the scikit-q Hamiltonian to a Qiskit Operator object. Qiskit using little endian convention, so we permute the order of the qubits. :return: Qiskit Operator object</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>def to_qiskit(self) -&gt; qiskit.quantum_info.Operator:\n    \"\"\"\n    Convert the scikit-q Hamiltonian to a Qiskit Operator object.\n    Qiskit using little endian convention, so we permute the order of the qubits.\n    :return: Qiskit Operator object\n    \"\"\"\n    return qiskit.quantum_info.Operator(self.convert_endianness())\n</code></pre>"},{"location":"api/quantum-info/#predefined-hamiltonians","title":"Predefined Hamiltonians","text":""},{"location":"api/quantum-info/#skq.quantum_info.IsingHamiltonian","title":"<code>skq.quantum_info.IsingHamiltonian</code>","text":"<p>               Bases: <code>Hamiltonian</code></p> <p>Hamiltonian for the Ising model. :param num_qubits: Number of qubits in the system. :param J: Interaction strength between qubits. :param h: Transverse field strength. :param hbar: The reduced Planck constant. Default is 1.0 (natural units).</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>class IsingHamiltonian(Hamiltonian):\n    \"\"\"\n    Hamiltonian for the Ising model.\n    :param num_qubits: Number of qubits in the system.\n    :param J: Interaction strength between qubits.\n    :param h: Transverse field strength.\n    :param hbar: The reduced Planck constant. Default is 1.0 (natural units).\n    \"\"\"\n\n    def __new__(cls, num_qubits: int, J: float, h: float, hbar: float = 1.0):\n        size = 2**num_qubits\n        H = np.zeros((size, size), dtype=complex)\n        # Interaction term: -J * sum(Z_i Z_{i+1})\n        for i in range(num_qubits - 1):\n            term = np.eye(1)\n            for j in range(num_qubits):\n                if j == i or j == i + 1:\n                    term = np.kron(term, Z())\n                else:\n                    term = np.kron(term, I())\n            H -= J * term\n\n        # Transverse field term: -h * sum(X_i)\n        for i in range(num_qubits):\n            term = np.eye(1)\n            for j in range(num_qubits):\n                if j == i:\n                    term = np.kron(term, X())\n                else:\n                    term = np.kron(term, I())\n            H -= h * term\n\n        return super().__new__(cls, H, hbar)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.HeisenbergHamiltonian","title":"<code>skq.quantum_info.HeisenbergHamiltonian</code>","text":"<p>               Bases: <code>Hamiltonian</code></p> <p>Hamiltonian for the Heisenberg model. :param num_qubits: Number of qubits in the system. :param J: Interaction strength between qubits. :param hbar: The reduced Planck constant. Default is 1.0 (natural units).</p> Source code in <code>src/skq/quantum_info/hamiltonian.py</code> <pre><code>class HeisenbergHamiltonian(Hamiltonian):\n    \"\"\"\n    Hamiltonian for the Heisenberg model.\n    :param num_qubits: Number of qubits in the system.\n    :param J: Interaction strength between qubits.\n    :param hbar: The reduced Planck constant. Default is 1.0 (natural units).\n    \"\"\"\n\n    def __new__(cls, num_qubits: int, J: float, hbar: float = 1.0):\n        size = 2**num_qubits\n        H = np.zeros((size, size), dtype=complex)\n\n        # Interaction term: J * sum(X_i X_{i+1} + Y_i Y_{i+1} + Z_i Z_{i+1})\n        for i in range(num_qubits - 1):\n            X_i = np.array([[0, 1], [1, 0]])\n            Y_i = np.array([[0, -1j], [1j, 0]])\n            Z_i = np.array([[1, 0], [0, -1]])\n            H += J * (np.kron(np.kron(np.eye(2**i), np.kron(X_i, X_i)), np.eye(2 ** (num_qubits - i - 2))) + np.kron(np.kron(np.eye(2**i), np.kron(Y_i, Y_i)), np.eye(2 ** (num_qubits - i - 2))) + np.kron(np.kron(np.eye(2**i), np.kron(Z_i, Z_i)), np.eye(2 ** (num_qubits - i - 2))))\n\n        return super().__new__(cls, H, hbar)\n</code></pre>"},{"location":"api/quantum-info/#hadamard-matrices","title":"Hadamard Matrices","text":"<p>Hadamard matrices are useful in quantum information theory and quantum algorithms.</p> <pre><code>from skq.quantum_info import generate_hadamard_matrix\n\n# Generate a Hadamard matrix of order 4\nH = generate_hadamard_matrix(4)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.HadamardMatrix","title":"<code>skq.quantum_info.HadamardMatrix</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Hadamard matrix representation.</p> Source code in <code>src/skq/quantum_info/hadamard.py</code> <pre><code>class HadamardMatrix(Operator):\n    \"\"\"Hadamard matrix representation.\"\"\"\n\n    def __new__(cls, input_array: np.array):\n        obj = super().__new__(cls, input_array)\n        obj = np.real(obj).astype(int)\n        assert obj.is_binary(), \"Hadamard matrix must have entries of +1 or -1.\"\n        assert obj.is_orthogonal(), \"Hadamard matrix must have orthogonal rows and columns.\"\n        assert obj.is_hadamard_order(), \"The order of a Hadamard matrix must be 1, 2, or a multiple of 4.\"\n        return obj\n\n    def is_binary(self) -&gt; bool:\n        \"\"\"All elements are +1 or -1.\"\"\"\n        return np.all(np.isin(self, [1, -1]))\n\n    def is_orthogonal(self) -&gt; bool:\n        \"\"\"Rows and columns are orthogonal.\"\"\"\n        n = self.shape[0]\n        return np.allclose(self @ self.T, n * np.eye(n))\n\n    def is_hadamard_order(self) -&gt; bool:\n        \"\"\"Order of the Hadamard matrix is 1, 2, or a multiple of 4.\"\"\"\n        n = self.shape[0]\n        return n == 1 or n == 2 or (n % 4 == 0)\n\n    def determinant(self) -&gt; float:\n        \"\"\"Determinant of the Hadamard matrix.\"\"\"\n        return np.linalg.det(self)\n\n    def equivalence(self, other: \"HadamardMatrix\") -&gt; bool:\n        \"\"\"Hadamard matrices are equivalent if row/column permutations and sign flips are equal.\"\"\"\n        permuted_matrices = self.permutations_and_sign_flips()\n        return any(np.array_equal(matrix, other) for matrix in permuted_matrices)\n\n    def spectral_norm(self) -&gt; float:\n        \"\"\"Spectral norm of the Hadamard matrix.\n        :return: largest singular value (i.e. spectral norm) of the Hadamard matrix.\n        \"\"\"\n        return np.linalg.norm(self, ord=2)\n\n    def permutations_and_sign_flips(self) -&gt; list[np.array]:\n        \"\"\"Generate all matrix permutations by permuting rows/columns and flipping signs.\"\"\"\n        n = self.shape[0]\n        matrices = []\n        for row_perm in permutations(range(n)):\n            for col_perm in permutations(range(n)):\n                permuted_matrix = self[row_perm, :][:, col_perm]\n                for signs in product([-1, 1], repeat=n):\n                    sign_matrix = np.diag(signs)\n                    matrices.append(sign_matrix @ permuted_matrix @ sign_matrix)\n        return matrices\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.HadamardMatrix.determinant","title":"<code>determinant()</code>","text":"<p>Determinant of the Hadamard matrix.</p> Source code in <code>src/skq/quantum_info/hadamard.py</code> <pre><code>def determinant(self) -&gt; float:\n    \"\"\"Determinant of the Hadamard matrix.\"\"\"\n    return np.linalg.det(self)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.HadamardMatrix.equivalence","title":"<code>equivalence(other)</code>","text":"<p>Hadamard matrices are equivalent if row/column permutations and sign flips are equal.</p> Source code in <code>src/skq/quantum_info/hadamard.py</code> <pre><code>def equivalence(self, other: \"HadamardMatrix\") -&gt; bool:\n    \"\"\"Hadamard matrices are equivalent if row/column permutations and sign flips are equal.\"\"\"\n    permuted_matrices = self.permutations_and_sign_flips()\n    return any(np.array_equal(matrix, other) for matrix in permuted_matrices)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.HadamardMatrix.is_binary","title":"<code>is_binary()</code>","text":"<p>All elements are +1 or -1.</p> Source code in <code>src/skq/quantum_info/hadamard.py</code> <pre><code>def is_binary(self) -&gt; bool:\n    \"\"\"All elements are +1 or -1.\"\"\"\n    return np.all(np.isin(self, [1, -1]))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.HadamardMatrix.is_hadamard_order","title":"<code>is_hadamard_order()</code>","text":"<p>Order of the Hadamard matrix is 1, 2, or a multiple of 4.</p> Source code in <code>src/skq/quantum_info/hadamard.py</code> <pre><code>def is_hadamard_order(self) -&gt; bool:\n    \"\"\"Order of the Hadamard matrix is 1, 2, or a multiple of 4.\"\"\"\n    n = self.shape[0]\n    return n == 1 or n == 2 or (n % 4 == 0)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.HadamardMatrix.is_orthogonal","title":"<code>is_orthogonal()</code>","text":"<p>Rows and columns are orthogonal.</p> Source code in <code>src/skq/quantum_info/hadamard.py</code> <pre><code>def is_orthogonal(self) -&gt; bool:\n    \"\"\"Rows and columns are orthogonal.\"\"\"\n    n = self.shape[0]\n    return np.allclose(self @ self.T, n * np.eye(n))\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.HadamardMatrix.permutations_and_sign_flips","title":"<code>permutations_and_sign_flips()</code>","text":"<p>Generate all matrix permutations by permuting rows/columns and flipping signs.</p> Source code in <code>src/skq/quantum_info/hadamard.py</code> <pre><code>def permutations_and_sign_flips(self) -&gt; list[np.array]:\n    \"\"\"Generate all matrix permutations by permuting rows/columns and flipping signs.\"\"\"\n    n = self.shape[0]\n    matrices = []\n    for row_perm in permutations(range(n)):\n        for col_perm in permutations(range(n)):\n            permuted_matrix = self[row_perm, :][:, col_perm]\n            for signs in product([-1, 1], repeat=n):\n                sign_matrix = np.diag(signs)\n                matrices.append(sign_matrix @ permuted_matrix @ sign_matrix)\n    return matrices\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.HadamardMatrix.spectral_norm","title":"<code>spectral_norm()</code>","text":"<p>Spectral norm of the Hadamard matrix. :return: largest singular value (i.e. spectral norm) of the Hadamard matrix.</p> Source code in <code>src/skq/quantum_info/hadamard.py</code> <pre><code>def spectral_norm(self) -&gt; float:\n    \"\"\"Spectral norm of the Hadamard matrix.\n    :return: largest singular value (i.e. spectral norm) of the Hadamard matrix.\n    \"\"\"\n    return np.linalg.norm(self, ord=2)\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.generate_hadamard_matrix","title":"<code>skq.quantum_info.generate_hadamard_matrix(order)</code>","text":"<p>Hadamard matrix of the given order using Sylvester's construction method. :param order: The order of the Hadamard matrix. Must be a power of 2. :return: HadamardMatrix of the specified order.</p> Source code in <code>src/skq/quantum_info/hadamard.py</code> <pre><code>def generate_hadamard_matrix(order: int) -&gt; HadamardMatrix:\n    \"\"\"\n    Hadamard matrix of the given order using Sylvester's construction method.\n    :param order: The order of the Hadamard matrix. Must be a power of 2.\n    :return: HadamardMatrix of the specified order.\n    \"\"\"\n    assert order &gt;= 1 and (order &amp; (order - 1)) == 0, \"Order must be a power of 2.\"\n\n    # Recurse block matrices to construct Hadamard matrix\n    if order == 2:\n        matrix = np.array([[1, 1], [1, -1]])\n    else:\n        H_prev = generate_hadamard_matrix(order // 2)\n        matrix = np.block([[H_prev, H_prev], [H_prev, -H_prev]])\n    return HadamardMatrix(matrix)\n</code></pre>"},{"location":"api/quantum-info/#superoperators","title":"Superoperators","text":"<p>Superoperators are linear maps that transform operators to operators.</p>"},{"location":"api/quantum-info/#skq.quantum_info.SuperOperator","title":"<code>skq.quantum_info.SuperOperator</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>Base class for quantum superoperators. For example quantum channels.</p> Source code in <code>src/skq/quantum_info/superoperator.py</code> <pre><code>class SuperOperator(np.ndarray):\n    \"\"\"Base class for quantum superoperators. For example quantum channels.\"\"\"\n\n    def __new__(cls, input_array: np.array):\n        arr = np.array(input_array, dtype=complex)\n        obj = arr.view(cls)\n        assert obj.is_at_least_nxn(n=1), \"Superoperator must be at least a 1x1 matrix.\"\n        assert obj.is_power_of_n_shape(n=2), \"Superoperator must have a power of 2 shape.\"\n        return obj\n\n    def is_at_least_nxn(self, n: int) -&gt; bool:\n        \"\"\"Superoperator is at least an n x n matrix.\"\"\"\n        return self.shape[0] &gt;= n and self.shape[1] &gt;= n\n\n    def is_power_of_n_shape(self, n: int) -&gt; bool:\n        \"\"\"\n        Superoperator shape is a power of n.\n        :param n: Number to check for power of n shape.\n        \"\"\"\n\n        def _is_power_of_n(x, n):\n            if x &lt; 1:\n                return False\n            while x % n == 0:\n                x //= n\n            return x == 1\n\n        return _is_power_of_n(self.shape[0], n) and _is_power_of_n(self.shape[1], n)\n\n    def conjugate_transpose(self) -&gt; np.ndarray:\n        \"\"\"\n        Conjugate transpose (i.e. Hermitian adjoint or 'dagger operation') of the superoperator.\n        1. Transpose the matrix\n        2. Take the complex conjugate of each element (Flip the sign of the imaginary part)\n        \"\"\"\n        return self.T.conj()\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.SuperOperator.conjugate_transpose","title":"<code>conjugate_transpose()</code>","text":"<p>Conjugate transpose (i.e. Hermitian adjoint or 'dagger operation') of the superoperator. 1. Transpose the matrix 2. Take the complex conjugate of each element (Flip the sign of the imaginary part)</p> Source code in <code>src/skq/quantum_info/superoperator.py</code> <pre><code>def conjugate_transpose(self) -&gt; np.ndarray:\n    \"\"\"\n    Conjugate transpose (i.e. Hermitian adjoint or 'dagger operation') of the superoperator.\n    1. Transpose the matrix\n    2. Take the complex conjugate of each element (Flip the sign of the imaginary part)\n    \"\"\"\n    return self.T.conj()\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.SuperOperator.is_at_least_nxn","title":"<code>is_at_least_nxn(n)</code>","text":"<p>Superoperator is at least an n x n matrix.</p> Source code in <code>src/skq/quantum_info/superoperator.py</code> <pre><code>def is_at_least_nxn(self, n: int) -&gt; bool:\n    \"\"\"Superoperator is at least an n x n matrix.\"\"\"\n    return self.shape[0] &gt;= n and self.shape[1] &gt;= n\n</code></pre>"},{"location":"api/quantum-info/#skq.quantum_info.SuperOperator.is_power_of_n_shape","title":"<code>is_power_of_n_shape(n)</code>","text":"<p>Superoperator shape is a power of n. :param n: Number to check for power of n shape.</p> Source code in <code>src/skq/quantum_info/superoperator.py</code> <pre><code>def is_power_of_n_shape(self, n: int) -&gt; bool:\n    \"\"\"\n    Superoperator shape is a power of n.\n    :param n: Number to check for power of n shape.\n    \"\"\"\n\n    def _is_power_of_n(x, n):\n        if x &lt; 1:\n            return False\n        while x % n == 0:\n            x //= n\n        return x == 1\n\n    return _is_power_of_n(self.shape[0], n) and _is_power_of_n(self.shape[1], n)\n</code></pre>"},{"location":"api/utils/","title":"Utils API Reference","text":"<p>This page documents the utility functions available in the <code>skq.utils</code> module.</p>"},{"location":"api/utils/#helper-functions","title":"Helper Functions","text":""},{"location":"api/utils/#skq.utils._check_quantum_state_array","title":"<code>skq.utils._check_quantum_state_array(X)</code>","text":"<p>Ensure that input are normalized state vectors of the right size.</p> Source code in <code>src/skq/utils.py</code> <pre><code>def _check_quantum_state_array(X):\n    \"\"\"Ensure that input are normalized state vectors of the right size.\"\"\"\n    if len(X.shape) != 2:\n        raise ValueError(\"Input must be a 2D array.\")\n\n    # Check if all inputs are complex\n    if not np.iscomplexobj(X):\n        raise ValueError(\"Input must be a complex array.\")\n\n    # Check if input is normalized.\n    normalized = np.allclose(np.linalg.norm(X, axis=-1), 1)\n    if not normalized:\n        not_normalized = X[np.linalg.norm(X, axis=-1) != 1]\n        raise ValueError(f\"Input state vectors must be normalized. Got non-normalized vectors: '{not_normalized}'\")\n\n    # Check if input is a valid state vector\n    _, n_states = X.shape\n    num_qubits = int(np.log2(n_states))\n    assert n_states == 2**num_qubits, f\"Expected state vector length {2**num_qubits}, got {n_states}.\"\n    return True\n</code></pre>"},{"location":"api/utils/#skq.utils.to_bitstring","title":"<code>skq.utils.to_bitstring(arr)</code>","text":"<p>Convert a 2D binary array to a list of bitstrings. :param arr: A 2D binary array For example: [[0, 1],  [1, 0]] :return: List of bitstrings For example: ['01', '10']</p> Source code in <code>src/skq/utils.py</code> <pre><code>def to_bitstring(arr: np.array) -&gt; list[str]:\n    \"\"\"\n    Convert a 2D binary array to a list of bitstrings.\n    :param arr: A 2D binary array\n    For example:\n    [[0, 1],\n     [1, 0]]\n    :return: List of bitstrings\n    For example:\n    ['01', '10']\n    \"\"\"\n    return [\"\".join(map(str, m)) for m in arr]\n</code></pre>"},{"location":"api/utils/#visualization-functions","title":"Visualization Functions","text":""},{"location":"api/utils/#skq.utils.matrix_heatmap","title":"<code>skq.utils.matrix_heatmap(matrix, title='Matrix Heatmap')</code>","text":"<p>Visualize a matrix as a heatmap. :param matrix: A 2D array :param title: Title of the plot :return: A plotly figure</p> Source code in <code>src/skq/utils.py</code> <pre><code>def matrix_heatmap(matrix: np.array, title: str = \"Matrix Heatmap\") -&gt; go.Figure:\n    \"\"\"\n    Visualize a matrix as a heatmap.\n    :param matrix: A 2D array\n    :param title: Title of the plot\n    :return: A plotly figure\n    \"\"\"\n    fig = go.Figure(data=go.Heatmap(z=np.real(matrix), colorscale=\"RdBu\", zmin=-1, zmax=1, text=np.real(matrix).round(3), texttemplate=\"%{text}\", textfont={\"size\": 10}, hoverongaps=False))\n    fig.update_layout(title=title, xaxis_title=\"Column Index\", yaxis_title=\"Row Index\", yaxis=dict(autorange=\"reversed\"))\n    return fig\n</code></pre>"},{"location":"api/utils/#skq.utils.bloch","title":"<code>skq.utils.bloch(state)</code>","text":"<p>Plot single qubit state on a Bloch sphere (3D plot). :param state: A statevector array for a single qubit :return: A plotly figure</p> Source code in <code>src/skq/utils.py</code> <pre><code>def bloch(state: np.array) -&gt; go.Figure:\n    \"\"\"\n    Plot single qubit state on a Bloch sphere (3D plot).\n    :param state: A statevector array for a single qubit\n    :return: A plotly figure\n    \"\"\"\n\n    def calculate_coordinates(theta, phi):\n        x = np.sin(theta) * np.cos(phi)\n        y = np.sin(theta) * np.sin(phi)\n        z = np.cos(theta)\n        return x, y, z\n\n    fig = go.Figure()\n    alpha, beta = state[0], state[1]\n    theta = 2 * np.arccos(np.abs(alpha))\n    phi = np.angle(beta) - np.angle(alpha)\n    x, y, z = calculate_coordinates(theta, phi)\n    surface_phi, surface_theta = np.mgrid[0 : 2 * np.pi : 100j, 0 : np.pi : 50j]\n    xs, ys, zs = calculate_coordinates(surface_theta, surface_phi)\n\n    fig.add_trace(go.Surface(x=xs, y=ys, z=zs, opacity=0.5, colorscale=\"Blues\", showscale=False))\n\n    fig.add_trace(go.Scatter3d(x=[0, x], y=[0, y], z=[0, z], mode=\"lines+markers+text\", marker=dict(size=10, color=\"green\"), line=dict(color=\"green\", width=8), textposition=\"top center\", showlegend=True, name=f\"{alpha:.3f}|0\u27e9 + {beta:.3f}|1\u27e9\"))\n\n    fig.add_trace(go.Scatter3d(x=[0, 0, 1, -1, 0, 0], y=[0, 0, 0, 0, 1, -1], z=[1, -1, 0, 0, 0, 0], mode=\"markers\", marker=dict(size=5, color=\"black\"), hovertext=[\"|0\u27e9\", \"|1\u27e9\", \"|+\u27e9\", \"|-\u27e9\", \"|i\u27e9\", \"|-i\u27e9\"], showlegend=False, name=\"Basis states\"))\n\n    boundary_phi = np.linspace(0, 2 * np.pi, 100)\n    coords = [(np.cos(boundary_phi), np.sin(boundary_phi), np.zeros_like(boundary_phi)), (np.zeros_like(boundary_phi), np.cos(boundary_phi), np.sin(boundary_phi)), (np.cos(boundary_phi), np.zeros_like(boundary_phi), np.sin(boundary_phi))]\n\n    for x, y, z in coords:\n        fig.add_trace(go.Scatter3d(x=x, y=y, z=z, mode=\"lines\", line=dict(color=\"black\", width=2), showlegend=False, name=\"Axes\"))\n\n    fig.update_layout(\n        legend=dict(\n            font=dict(size=20),\n            x=0.05,\n            y=0.95,\n            xanchor=\"left\",\n            yanchor=\"top\",\n            bgcolor=\"rgba(0,0,0,0)\",\n        ),\n        margin=dict(l=0, r=0, t=0, b=0),\n    )\n    return fig\n</code></pre>"},{"location":"api/utils/#quantum-operations","title":"Quantum Operations","text":""},{"location":"api/utils/#skq.utils.measure_state","title":"<code>skq.utils.measure_state(state)</code>","text":"<p>Measure a quantum state and return a classical bit. :param state: A statevector array :return: A classical bit</p> Source code in <code>src/skq/utils.py</code> <pre><code>def measure_state(state: np.array) -&gt; int:\n    \"\"\"\n    Measure a quantum state and return a classical bit.\n    :param state: A statevector array\n    :return: A classical bit\n    \"\"\"\n    # Absolute value squared gives us the probability distribution from the statevector\n    p = np.abs(state) ** 2\n    # Sample from probability distribution to get classical bits\n    return np.random.choice([0, 1], p=p)\n</code></pre>"},{"location":"tutorials/building-circuits/","title":"Building Quantum Circuits","text":"<p>This tutorial explains how to build quantum circuits from scratch using <code>skq</code>. We'll cover:</p> <ol> <li>Creating basic circuits</li> <li>Combining gates in different ways</li> <li>Building parameterized circuits</li> <li>Creating custom gates</li> </ol>"},{"location":"tutorials/building-circuits/#basic-circuit-construction","title":"Basic Circuit Construction","text":"<p>In <code>skq</code>, a circuit is a sequence of quantum gates that are applied to a quantum state:</p> <pre><code>from skq.gates import H, X\nfrom skq.circuits import Circuit\nimport numpy as np\n\n# Create a simple circuit that applies H then X to a single qubit\ncircuit = Circuit([H(), X()])\n\n# Apply to |0\u27e9 state\nstate = np.array([1, 0])\nresult = circuit(state)\nprint(result)\n# Output: [0.70710678+0.j -0.70710678+0.j]\n</code></pre>"},{"location":"tutorials/building-circuits/#multi-qubit-circuits","title":"Multi-Qubit Circuits","text":"<p>For multi-qubit circuits, you need to specify how gates act on different qubits:</p> <pre><code>from skq.gates import H, I, CX\nfrom skq.circuits import Circuit, Concat\n\n# Create a Bell state circuit\nbell_circuit = Circuit([\n    Concat([H(), I()]),  # Apply H to first qubit, I to second qubit\n    CX()                 # Apply CNOT with first qubit as control\n])\n\n# Apply to |00\u27e9 state\nstate = np.array([1, 0, 0, 0])\nresult = bell_circuit(state)\nprint(result)\n# Output: [0.70710678+0.j 0.        +0.j 0.        +0.j 0.70710678+0.j]\n</code></pre>"},{"location":"tutorials/building-circuits/#custom-gates","title":"Custom Gates","text":"<p>You can create custom gates by defining their matrix representation:</p> <pre><code>import numpy as np\nfrom skq.gates.qubit import QubitGate\n\n# Define a custom gate as a subclass of Gate\nclass MySqrtX(QubitGate):\n    def __init__(self):\n        # Define the matrix for \u221aX gate\n        matrix = np.array([\n            [0.5 + 0.5j, 0.5 - 0.5j],\n            [0.5 - 0.5j, 0.5 + 0.5j]\n        ])\n        super().__init__(matrix)\n\n# Use the custom gate\nsqrt_x = MySqrtX()\ncircuit = Circuit([sqrt_x])\n\n# Apply to |0\u27e9 state\nstate = np.array([1, 0])\nresult = circuit(state)\nprint(result)\n# Output: [0.5+0.5j 0.5-0.5j]\n</code></pre>"},{"location":"tutorials/building-circuits/#controlled-operations","title":"Controlled Operations","text":"<p>You can create controlled versions of any gate:</p> <pre><code>from skq.gates import X, controlled\nimport numpy as np\n\n# Create a controlled-X gate (equivalent to CX)\ncx_gate = controlled(X())\n\n# Apply to |10\u27e9 state\nstate = np.array([0, 1, 0, 0])\nresult = cx_gate @ state\nprint(result)\n# Output: [0 0 0 1]\n# This is |11\u27e9\n</code></pre>"},{"location":"tutorials/building-circuits/#circuit-visualization","title":"Circuit Visualization","text":"<pre><code>from skq.circuits import Circuit, Concat\nfrom skq.gates import H, I, CX\n\n# Create a Bell state circuit\nbell_circuit = Circuit([\n    Concat([H(), I()]),\n    CX()\n])\n\n# ASCII\nbell_circuit.draw()\n# Matplotlib\nbell_circuit.draw(output=\"mpl\")\n</code></pre>"},{"location":"tutorials/building-circuits/#next-steps","title":"Next Steps","text":"<p>Now that you know how to build circuits, you can:</p> <ol> <li>Learn about Circuit Conversion to other frameworks</li> </ol>"},{"location":"tutorials/circuit-conversion/","title":"Circuit Conversion","text":"<p>One of the key features of <code>skq</code> is the ability to convert quantum circuits to other popular quantum computing frameworks. This allows you to:</p> <ol> <li>Design and test circuits in <code>skq</code> using NumPy</li> <li>Convert them to other frameworks for execution on real quantum hardware</li> <li>Leverage the strengths of different frameworks</li> </ol>"},{"location":"tutorials/circuit-conversion/#supported-frameworks","title":"Supported Frameworks","text":"<p>Currently, <code>skq</code> supports conversion to:</p> <ul> <li>Qiskit - IBM's quantum computing framework</li> <li>OpenQASM - Open Quantum Assembly Language</li> </ul>"},{"location":"tutorials/circuit-conversion/#converting-to-qiskit","title":"Converting to Qiskit","text":"<p>To convert a circuit to Qiskit:</p> <pre><code>from skq.gates import H, I, CX\nfrom skq.circuits import Circuit, Concat\n\n# Create a Bell state circuit\nbell_circuit = Circuit([\n    Concat([H(), I()]),  # Apply H to first qubit, I to second qubit\n    CX()                 # Apply CNOT with first qubit as control\n])\n\n# Convert to Qiskit\nqiskit_circuit = bell_circuit.convert(framework=\"qiskit\")\n\n# Draw the circuit\nprint(qiskit_circuit.draw())\n# Output:\n#      \u250c\u2500\u2500\u2500\u2510     \n# q_0: \u2524 H \u251c\u2500\u2500\u25a0\u2500\u2500\n#      \u2514\u2500\u2500\u2500\u2518\u250c\u2500\u2534\u2500\u2510\n# q_1: \u2500\u2500\u2500\u2500\u2500\u2524 X \u251c\n#           \u2514\u2500\u2500\u2500\u2518\n\n# You can now use all Qiskit features\nfrom qiskit import Aer, execute\n\n# Run on Qiskit simulator\nsimulator = Aer.get_backend('statevector_simulator')\nresult = execute(qiskit_circuit, simulator).result()\nstatevector = result.get_statevector()\nprint(statevector)\n# Output: [0.70710678+0.j 0.        +0.j 0.        +0.j 0.70710678+0.j]\n</code></pre>"},{"location":"tutorials/circuit-conversion/#converting-to-openqasm","title":"Converting to OpenQASM","text":"<p>OpenQASM is a text-based representation of quantum circuits:</p> <pre><code># Convert to OpenQASM\nqasm_code = bell_circuit.convert(framework=\"qasm\")\nprint(qasm_code)\n# Output:\n# h q[0];\n# cx q[0], q[1];\n</code></pre>"},{"location":"tutorials/circuit-conversion/#converting-complex-algorithms","title":"Converting Complex Algorithms","text":"<p>You can also convert more complex algorithms:</p> <pre><code>from skq.circuits import Grover\nimport numpy as np\n\n# Create a Grover search circuit for 3 qubits\n# Searching for state |100\u27e9 (binary 4)\ntarget_state = np.zeros(8)\ntarget_state[4] = 1\n\ngrover_circuit = Grover().circuit(\n    n_qubits=3,\n    target_state=target_state,\n    n_iterations=1\n)\n\n# Convert to Qiskit\nqiskit_grover = grover_circuit.convert(framework=\"qiskit\")\nqiskit_grover.draw()\n</code></pre>"},{"location":"tutorials/circuit-conversion/#handling-framework-specific-features","title":"Handling Framework-Specific Features","text":"<p>When converting circuits, <code>skq</code> handles framework-specific features automatically:</p> <ul> <li>Identity gates are removed when not needed</li> <li>Gates are mapped to their framework-specific equivalents</li> <li>Circuit structure is preserved</li> </ul>"},{"location":"tutorials/circuit-conversion/#limitations","title":"Limitations","text":"<p>There are some limitations to be aware of:</p> <ol> <li>Not all quantum operations have direct equivalents in all frameworks</li> <li>Custom gates may require special handling</li> <li>Some framework-specific optimizations may not be applied</li> </ol>"},{"location":"tutorials/circuit-conversion/#next-steps","title":"Next Steps","text":"<p>Now that you know how to convert circuits, you can:</p> <ol> <li>Learn how to build circuits from scratch</li> </ol>"}]}